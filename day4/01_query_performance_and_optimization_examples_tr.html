<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr">

<head>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="../style_bootstrap.html">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/code.css">
    <link href="https://cdn.prod.website-files.com/5efdb54f07a6812bcd95cc65/6773d0fc3013e060f08d7145_favicon.jpg"
        rel="shortcut icon" type="image/x-icon">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Gun 4: Sorgu Performansi (Query Performance) ve Optimizasyon (Optimization) - Pratik Ornekler</title>
    <style>
        code {
            white-space: pre-wrap;
        }

        span.smallcaps {
            font-variant: small-caps;
        }

        span.underline {
            text-decoration: underline;
        }

        div.column {
            display: inline-block;
            vertical-align: top;
            width: 50%;
        }

        div.hanging-indent {
            margin-left: 1.5em;
            text-indent: -1.5em;
        }

        ul.task-list {
            list-style: none;
        }

        .exercise-box {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .exercise-box h4 {
            color: #495057;
            margin-bottom: 15px;
        }

        .solution-content {
            background-color: #e8f5e9;
            border: 1px solid #a5d6a7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .solution-content.show {
            display: block;
        }

        .solution-toggle {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .solution-toggle:hover {
            background-color: #218838;
        }

        .hint-box {
            background-color: #fff3cd;
            border: 1px solid #ffecb5;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .hint-box strong {
            color: #664d03;
        }

        .warning-box {
            background-color: #f8d7da;
            border: 1px solid #f5c2c7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .warning-box strong {
            color: #842029;
        }

        .concept-box {
            background-color: #d1e7dd;
            border: 1px solid #badbcc;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .concept-box strong {
            color: #0f5132;
        }

        .dataset-table {
            font-size: 0.9em;
            margin: 15px 0;
        }

        .dataset-table th {
            background-color: #e9ecef;
        }

        .badge-operation {
            font-size: 0.75em;
            padding: 4px 8px;
            border-radius: 4px;
            margin-right: 5px;
        }

        .badge-scan {
            background-color: #dc3545;
            color: white;
        }

        .badge-index {
            background-color: #198754;
            color: white;
        }

        .badge-join {
            background-color: #0d6efd;
            color: white;
        }

        .badge-sort {
            background-color: #ffc107;
            color: black;
        }

        .badge-aggregate {
            background-color: #6f42c1;
            color: white;
        }

        .plan-output {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
        }

        .plan-good {
            border-left: 4px solid #198754;
        }

        .plan-bad {
            border-left: 4px solid #dc3545;
        }

        .comparison-table {
            width: 100%;
            margin: 15px 0;
        }

        .comparison-table td {
            vertical-align: top;
            padding: 10px;
        }

        .comparison-table .slow {
            background-color: #f8d7da;
        }

        .comparison-table .fast {
            background-color: #d1e7dd;
        }

        .language-switcher {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .language-switcher a {
            text-decoration: none;
            padding: 5px 10px;
            margin: 0 2px;
            border-radius: 3px;
            color: #333;
        }
        .language-switcher a.active {
            background: #0d6efd;
            color: #fff;
        }
        .language-switcher a:hover:not(.active) {
            background: #e9ecef;
        }
    </style>
</head>

<body>
    <a href="../index.html" class="back-button">← Anasayfaya Don</a>
    <div class="language-switcher">
        <a href="01_query_performance_and_optimization_examples.html">EN</a>
        <a href="01_query_performance_and_optimization_examples_tr.html" class="active">TR</a>
    </div>

    <div class="copy-notification" id="copyNotification">Kopyalandi!</div>

    <div id="europeanunion-turkey">
        <img src="../static/eu.png" alt="">
    </div>
    <div id="sanayiteknolojibakan">
        <img src="../static/sanayitek.png" alt="">
    </div>
    <div id="rekabet">
        <img src="../static/rekabet.png" alt="">
    </div>
    <div id="tisk">
        <img src="../static/tisk.png" alt="">
    </div>
    <div id="undp">
        <img src="../static/undp.png" alt="">
    </div>
    <div class="content-container">
        <div class="container">
            <section>
                <h1>Sorgu Performansi (Query Performance) ve Optimizasyon (Optimization) - Pratik Ornekler</h1>
                <p class="lead">Uygulamali alistirmalarla yurutme planlarini (Execution Plans), indeksleme stratejilerini (Indexing Strategies) ve sorgu optimizasyon tekniklerini (Query Optimization Techniques) ogrenmek.</p>

                <div class="hint-box">
                    <strong>Ogrenme Hedefleri (Learning Objectives):</strong>
                    <ul class="mb-0">
                        <li>EXPLAIN ciktisini okumak ve yorumlamak</li>
                        <li>Yurutme planlarindaki (Execution Plans) performans darbogazlarini (Bottlenecks) tanimlamak</li>
                        <li>Farkli sorgu kaliplari (Query Patterns) icin etkili indeksler (Indexes) tasarlamak</li>
                        <li>Yavas sorgulari daha iyi performans icin yeniden yazmak (Rewrite)</li>
                    </ul>
                </div>
            </section>

            <!-- Ornek Veri Seti -->
            <section>
                <h3>Ornek Veritabani Semasi (Sample Database Schema)</h3>
                <p>Asagidaki tablolara sahip bir e-ticaret veritabani kullanacagiz:</p>

                <div class="row">
                    <div class="col-md-6">
                        <h5>customers (sales semasi)</h5>
                        <table class="table table-bordered dataset-table">
                            <thead>
                                <tr>
                                    <th>Sutun</th>
                                    <th>Tip</th>
                                    <th>Notlar</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>id</td>
                                    <td><span class="badge bg-primary">SERIAL PK</span></td>
                                    <td>Birincil Anahtar (Primary Key)</td>
                                </tr>
                                <tr>
                                    <td>email</td>
                                    <td><span class="badge bg-secondary">VARCHAR(100)</span></td>
                                    <td>Benzersiz</td>
                                </tr>
                                <tr>
                                    <td>first_name</td>
                                    <td><span class="badge bg-secondary">VARCHAR(50)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>last_name</td>
                                    <td><span class="badge bg-secondary">VARCHAR(50)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>country_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK -> countries</td>
                                </tr>
                                <tr>
                                    <td>is_active</td>
                                    <td><span class="badge bg-info">BOOLEAN</span></td>
                                    <td>%90 TRUE</td>
                                </tr>
                                <tr>
                                    <td>created_at</td>
                                    <td><span class="badge bg-warning text-dark">TIMESTAMP</span></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                        <p><strong>Ornekler icin buyuk tablo</strong></p>
                    </div>
                    <div class="col-md-6">
                        <h5>orders (sales semasi)</h5>
                        <table class="table table-bordered dataset-table">
                            <thead>
                                <tr>
                                    <th>Sutun</th>
                                    <th>Tip</th>
                                    <th>Notlar</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>id</td>
                                    <td><span class="badge bg-primary">SERIAL PK</span></td>
                                    <td>Birincil Anahtar (Primary Key)</td>
                                </tr>
                                <tr>
                                    <td>customer_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK -> customers.id</td>
                                </tr>
                                <tr>
                                    <td>order_date</td>
                                    <td><span class="badge bg-warning text-dark">DATE</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>status</td>
                                    <td><span class="badge bg-secondary">VARCHAR(20)</span></td>
                                    <td>draft, confirmed, processing, shipped, delivered, cancelled, returned</td>
                                </tr>
                                <tr>
                                    <td>total_amount</td>
                                    <td><span class="badge bg-info">DECIMAL(10,2)</span></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                        <p><strong>Ornekler icin buyuk tablo</strong></p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <h5>order_lines (sales semasi)</h5>
                        <table class="table table-bordered dataset-table">
                            <thead>
                                <tr>
                                    <th>Sutun</th>
                                    <th>Tip</th>
                                    <th>Notlar</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>id</td>
                                    <td><span class="badge bg-primary">SERIAL PK</span></td>
                                    <td>Birincil Anahtar (Primary Key)</td>
                                </tr>
                                <tr>
                                    <td>order_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK -> orders.id</td>
                                </tr>
                                <tr>
                                    <td>product_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK -> products.id</td>
                                </tr>
                                <tr>
                                    <td>quantity</td>
                                    <td><span class="badge bg-info">INTEGER</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>unit_price</td>
                                    <td><span class="badge bg-info">DECIMAL(10,2)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>line_total</td>
                                    <td><span class="badge bg-info">DECIMAL(10,2)</span></td>
                                    <td>quantity * unit_price</td>
                                </tr>
                            </tbody>
                        </table>
                        <p><strong>Ornekler icin buyuk tablo</strong></p>
                    </div>
                    <div class="col-md-6">
                        <h5>products (sales semasi)</h5>
                        <table class="table table-bordered dataset-table">
                            <thead>
                                <tr>
                                    <th>Sutun</th>
                                    <th>Tip</th>
                                    <th>Notlar</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>id</td>
                                    <td><span class="badge bg-primary">SERIAL PK</span></td>
                                    <td>Birincil Anahtar (Primary Key)</td>
                                </tr>
                                <tr>
                                    <td>name</td>
                                    <td><span class="badge bg-secondary">VARCHAR(200)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>category_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK -> categories.id</td>
                                </tr>
                                <tr>
                                    <td>price</td>
                                    <td><span class="badge bg-info">DECIMAL(10,2)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>is_active</td>
                                    <td><span class="badge bg-info">BOOLEAN</span></td>
                                    <td>%95 TRUE</td>
                                </tr>
                            </tbody>
                        </table>
                        <p><strong>Daha kucuk referans tablosu</strong></p>
                    </div>
                </div>

                <div class="concept-box">
                    <strong>Baslangic Indeksleri (Initial Indexes) (Yalnizca Birincil Anahtarlar (Primary Keys Only)):</strong><br>
                    Veritabani yalnizca birincil anahtar indeksleriyle (Primary Key Indexes) baslar. Yabanci anahtar (Foreign Key) sutunlarinda henuz indeks yoktur.
                </div>
            </section>

            <!-- Bolum 1: Yurutme Planlarini Okuma -->
            <section>
                <h2>Bolum 1: Yurutme Planlarini (Execution Plans) Okuma</h2>
                <p>EXPLAIN ciktisini yorumlamayi ve performans sorunlarini (Performance Issues) tanımlamayi ogrenin.</p>

                <div class="exercise-box">
                    <h4>Alistirma 1.1: Temel Plan Islemlerini (Basic Plan Operations) Anlama</h4>
                    <p>Asagidaki PostgreSQL EXPLAIN ciktisina gore, islemleri tanimlayin ve performans ozelliklerini tahmin edin:</p>

                    <div class="plan-output plan-bad">
<pre>EXPLAIN SELECT * FROM sales.orders WHERE status = 'processing';

Seq Scan on orders  (cost=0.00..45123.00 rows=150000 width=52)
  Filter: ((status)::text = 'processing'::text)
</pre>
                    </div>

                    <p><strong>Sorular:</strong></p>
                    <ol>
                        <li>Hangi islem gerceklestiriliyor?</li>
                        <li>2 milyon satirlik bir tablo icin neden verimsiz olabilir?</li>
                        <li>Maliyet tahmini (0.00..45123.00) neyi temsil ediyor?</li>
                    </ol>

                    <button class="solution-toggle" onclick="toggleSolution('sol1_1')">Cozumu Goster</button>
                    <div id="sol1_1" class="solution-content">
                        <p><strong>Cevaplar:</strong></p>
                        <ol>
                            <li><span class="badge badge-operation badge-scan">Seq Scan</span> - Bir <strong>Sequential Scan</strong> (Sirali Tarama / Tam Tablo Taramasi (Full Table Scan)) tablodaki her satiri okur.</li>
                            <li>Sorgu yalnizca ~150.000 satir (%7.5 / 2M) gerektiriyor, ancak TUM 2 milyon satiri okuyor. Bu, I/O (Girdi/Cikti) ve CPU israfina neden olur.</li>
                            <li>Maliyet (Cost) iki sayiya sahiptir:
                                <ul>
                                    <li><strong>0.00</strong> = baslangic maliyeti (Startup Cost) (ilk satir donmeden onceki is)</li>
                                    <li><strong>45123.00</strong> = keyfi birimlerde toplam maliyet (Total Cost) (yuksek = yavas)</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>Optimizasyon (Optimization):</strong> <code>status</code> sutununda bir indeks (Index) olusturun:</p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_status <span class="kw">ON</span> orders (status);</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Alistirma 1.2: Plan Islemlerini (Plan Operations) Karsilastirma</h4>
                    <p>Indeks (Index) eklendikten sonra ayni sorgu icin bu iki yurutme planini (Execution Plans) karsilastirin:</p>

                    <div class="row">
                        <div class="col-md-6">
                            <h6>Once (Indeks (Index) Yok):</h6>
                            <div class="plan-output plan-bad">
<pre>Seq Scan on orders
  (cost=0.00..45123.00 rows=150000)
  Filter: status = 'processing'

Actual Time: 892.45ms
Rows Returned: 148,532</pre>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <h6>Sonra (Indeks (Index) Var):</h6>
                            <div class="plan-output plan-good">
<pre>Bitmap Heap Scan on orders
  (cost=1523.00..28456.00 rows=150000)
  Recheck Cond: status = 'processing'
  -> Bitmap Index Scan on idx_orders_status
       (cost=0.00..1485.00 rows=150000)

Actual Time: 124.32ms
Rows Returned: 148,532</pre>
                            </div>
                        </div>
                    </div>

                    <p><strong>Sorular:</strong></p>
                    <ol>
                        <li>Optimize edilmis planda hangi yeni islemler gorunuyor?</li>
                        <li>Performans iyilestirmesini hesaplayin.</li>
                        <li>PostgreSQL neden basit bir Index Scan yerine Bitmap scan kullaniyor?</li>
                    </ol>

                    <button class="solution-toggle" onclick="toggleSolution('sol1_2')">Cozumu Goster</button>
                    <div id="sol1_2" class="solution-content">
                        <p><strong>Cevaplar:</strong></p>
                        <ol>
                            <li>
                                <span class="badge badge-operation badge-index">Bitmap Index Scan</span> (Bitmap Indeks Taramasi) - Eslesen satirlarin bir bitmap'ini olusturmak icin indeksi tarar<br>
                                <span class="badge badge-operation badge-scan">Bitmap Heap Scan</span> (Bitmap Yigin Taramasi) - Tablodan gercek satirlari almak icin bitmap'i kullanir
                            </li>
                            <li>Performans iyilestirmesi (Performance Improvement): <strong>892.45ms -> 124.32ms = 7.2x daha hizli</strong><br>
                                Maliyet azalmasi (Cost Reduction): 45123 -> 28456 = %37 daha dusuk tahmini maliyet (Estimated Cost)</li>
                            <li>PostgreSQL, cok sayida satir alirken (%7.5 tablo) Bitmap Scan kullanir. Buyuk sonuc kumeleri (Large Result Sets) icin Index Scan'den daha verimlidir cunku:
                                <ul>
                                    <li>Satir konumlarini siralayarak rastgele I/O'yu (Random I/O) azaltir</li>
                                    <li>Birden fazla indeks kosulunu verimli bir sekilde birlestirebilir</li>
                                    <li>Basit bir Index Scan cok fazla rastgele disk aramasina (Random Disk Seeks) neden olur</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Alistirma 1.3: Join (Birlestirme) Islemlerini Tanimlama</h4>
                    <p>Bir join (birlestirme) sorgusu icin bu yurutme planini (Execution Plan) analiz edin:</p>

                    <pre><code class="sourceCode sql"><span class="kw">SELECT</span> c.email, o.order_date, o.total_amount
<span class="kw">FROM</span> customers c
<span class="kw">JOIN</span> orders o <span class="kw">ON</span> c.customer_id = o.customer_id
<span class="kw">WHERE</span> c.country = <span class="st">'Germany'</span>
  <span class="kw">AND</span> o.order_date >= <span class="st">'2024-01-01'</span>;</code></pre>

                    <div class="plan-output plan-bad">
<pre>Hash Join  (cost=15234.00..98765.00 rows=25000 width=48)
  Hash Cond: (o.customer_id = c.customer_id)
  ->  Seq Scan on orders o  (cost=0.00..45123.00 rows=500000 width=20)
        Filter: (order_date >= '2024-01-01')
  ->  Hash  (cost=12456.00..12456.00 rows=12500 width=36)
        ->  Seq Scan on customers c  (cost=0.00..12456.00 rows=12500 width=36)
              Filter: (country = 'Germany')
</pre>
                    </div>

                    <p><strong>Sorular:</strong></p>
                    <ol>
                        <li>Hangi join (birlestirme) algoritmasi kullaniliyor?</li>
                        <li>Tum sequential scan'leri (Sirali Taramalar) tanimlayin - hangileri indekslerden (Indexes) fayda saglayabilir?</li>
                        <li>Bu sorguyu optimize etmek icin hangi indeksleri (Indexes) olusturursunuz?</li>
                    </ol>

                    <button class="solution-toggle" onclick="toggleSolution('sol1_3')">Cozumu Goster</button>
                    <div id="sol1_3" class="solution-content">
                        <p><strong>Cevaplar:</strong></p>
                        <ol>
                            <li><span class="badge badge-operation badge-join">Hash Join</span> (Hash Birlestirme) - Daha kucuk sonuctan (Almanya'daki musteriler) bir hash tablosu (Hash Table) olusturur ve bunu daha buyuk sonucla (siparisler) sorgular.</li>
                            <li>Iki sequential scan (Sirali Tarama) tanimlandi:
                                <ul>
                                    <li><code>customers</code> - <code>country = 'Germany'</code> ile filtrelenmis - Indeksten (Index) faydalanir</li>
                                    <li><code>orders</code> - <code>order_date >= '2024-01-01'</code> ile filtrelenmis - Indeksten (Index) faydalanir</li>
                                </ul>
                            </li>
                            <li>Onerilen indeksler (Recommended Indexes):
                                <pre><code class="sourceCode sql"><span class="co">-- Musteri ulke filtresi icin indeks (Index for Customer Country Filter)</span>
<span class="kw">CREATE INDEX</span> idx_customers_country <span class="kw">ON</span> customers (country);

<span class="co">-- Siparis tarih araligi filtresi icin indeks (Index for Order Date Range Filter)</span>
<span class="kw">CREATE INDEX</span> idx_orders_date <span class="kw">ON</span> orders (order_date);

<span class="co">-- Join kosulu icin indeks (Index for Join Condition) (kritik!)</span>
<span class="kw">CREATE INDEX</span> idx_orders_customer_id <span class="kw">ON</span> orders (customer_id);</code></pre>
                            </li>
                        </ol>
                        <p>Indekslerden sonra, plan cok daha iyi performans icin Index Scan'lerle (Indeks Taramasi) Nested Loop (Ic Ice Dongu) kullanabilir.</p>
                    </div>
                </div>
            </section>

            <!-- Bolum 2: Indeks Tasarimi -->
            <section>
                <h2>Bolum 2: Indeks Tasarimi (Index Design) Alistirmalari</h2>
                <p>Farkli sorgu kaliplari (Query Patterns) icin optimal indeksler (Indexes) tasarlamayi pratik yapin.</p>

                <div class="exercise-box">
                    <h4>Alistirma 2.1: Tek Sutun (Single-Column) vs Bilesik (Composite) Indeks</h4>
                    <p>Sik calistirilan su iki sorgunuz var:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Sorgu A: Duruma gore siparisleri bul</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> orders <span class="kw">WHERE</span> status = <span class="st">'shipped'</span>;

<span class="co">-- Sorgu B: Tarih araliginda gonderilmis siparisleri bul</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> orders
<span class="kw">WHERE</span> status = <span class="st">'shipped'</span>
  <span class="kw">AND</span> order_date <span class="kw">BETWEEN</span> <span class="st">'2024-01-01'</span> <span class="kw">AND</span> <span class="st">'2024-03-31'</span>;</code></pre>

                    <p><strong>Gorev:</strong> Her iki sorguyu da verimli bir sekilde desteklemek icin optimal indeks(ler)i (Indexes) tasarlayin.</p>

                    <div class="hint-box">
                        <strong>Ipucu (Hint):</strong> Bilesik indekslerdeki (Composite Indexes) sutun sirasini dikkate alin. Esitlik kosullari (Equality Conditions) aralik kosullarindan (Range Conditions) once gelmelidir.
                    </div>

                    <button class="solution-toggle" onclick="toggleSolution('sol2_1')">Cozumu Goster</button>
                    <div id="sol2_1" class="solution-content">
                        <p><strong>Optimal Cozum (Optimal Solution):</strong> BIR bilesik indeks (Composite Index) olusturun:</p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_status_date <span class="kw">ON</span> orders (status, order_date);</code></pre>

                        <p><strong>Neden calisiyor (Why it works):</strong></p>
                        <ul>
                            <li><strong>Sorgu A (Query A)</strong>: En soldaki sutunu (Leftmost Column) (status) kullanir - indeks kullanilir</li>
                            <li><strong>Sorgu B (Query B)</strong>: Her iki sutunu da kullanir - once status esitligi (Equality), sonra tarih araligi (Range)</li>
                        </ul>

                        <p><strong>Neden ayri indeksler degil? (Why not separate indexes?)</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Daha az optimal yaklasim:</span>
<span class="kw">CREATE INDEX</span> idx_orders_status <span class="kw">ON</span> orders (status);
<span class="kw">CREATE INDEX</span> idx_orders_date <span class="kw">ON</span> orders (order_date);</code></pre>
                        <ul>
                            <li>Sorgu B'nin iki indeksi birlestirmesi (Bitmap AND) veya yalnizca birini secmesi gerekir</li>
                            <li>Daha fazla indeks = daha fazla depolama (Storage) ve daha yavas yazmalar (Slower Writes)</li>
                        </ul>

                        <div class="warning-box">
                            <strong>Sutun Sirasi Onemlidir! (Column Order Matters!)</strong><br>
                            <code>(order_date, status)</code> uzerindeki bir indeks, Sorgu A'yi verimli bir sekilde desteklemez cunku en soldaki sutun (Leftmost Column) kullanilmaz.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Alistirma 2.2: Kismi Indeks (Partial Index) Tasarimi</h4>
                    <p>Uygulamaniz sik sik su sorguyu calistiriyor:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Takip icin isleniyor durumundaki siparisleri bul</span>
<span class="kw">SELECT</span> id, customer_id, order_date, total_amount
<span class="kw">FROM</span> sales.orders
<span class="kw">WHERE</span> status = <span class="st">'processing'</span>
<span class="kw">ORDER BY</span> order_date;</code></pre>

                    <p>Veri dagilimi (Data Distribution): Siparislerin yalnizca %2'si status = 'processing' durumunda (karsilanmayi bekleyen siparisler).</p>

                    <p><strong>Gorev:</strong> Bu sorgu icin en verimli indeksi (Index) tasarlayin.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol2_2')">Cozumu Goster</button>
                    <div id="sol2_2" class="solution-content">
                        <p><strong>Optimal Cozum (Optimal Solution):</strong> Kismi indeks (Partial Index) olusturun:</p>
                        <pre><code class="sourceCode sql"><span class="co">-- PostgreSQL kismi indeks (Partial Index)</span>
<span class="kw">CREATE INDEX</span> idx_orders_processing_date
<span class="kw">ON</span> sales.orders (order_date)
<span class="kw">WHERE</span> status = <span class="st">'processing'</span>;</code></pre>

                        <p><strong>Faydalar (Benefits):</strong></p>
                        <table class="table table-bordered">
                            <tr>
                                <th>Metrik (Metric)</th>
                                <th>Tam Indeks (Full Index)</th>
                                <th>Kismi Indeks (Partial Index)</th>
                            </tr>
                            <tr>
                                <td>Indekslenen satirlar (Indexed Rows)</td>
                                <td>Tum siparisler</td>
                                <td>Yalnizca processing (kucuk %)</td>
                            </tr>
                            <tr>
                                <td>Indeks boyutu (Index Size)</td>
                                <td>Buyuk</td>
                                <td>Cok daha kucuk</td>
                            </tr>
                            <tr>
                                <td>Insert yuku (Insert Overhead)</td>
                                <td>Her insert</td>
                                <td>Yalnizca processing siparisler</td>
                            </tr>
                        </table>

                        <p><strong>SQL Server esdegeri (Filtrelenmis Indeks / Filtered Index):</strong></p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_processing_date
<span class="kw">ON</span> orders (order_date)
<span class="kw">WHERE</span> status = <span class="st">'processing'</span>;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Alistirma 2.3: Kapsayici Indeks (Covering Index) Tasarimi</h4>
                    <p>Bu sorgu kontrol panelinizde dakikada binlerce kez calistirilir:</p>

                    <pre><code class="sourceCode sql"><span class="kw">SELECT</span> order_date, total_amount
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">10</span>;</code></pre>

                    <p><strong>Gorev:</strong> Bu sorgunun tamamen indeksten yanit alinmasini saglayan bir indeks (Index) tasarlayin (Yalnizca Indeks Taramasi / Index-Only Scan).</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol2_3')">Cozumu Goster</button>
                    <div id="sol2_3" class="solution-content">
                        <p><strong>Cozum - Kapsayici Indeks (Covering Index):</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- PostgreSQL (anahtar olmayan sutunlari dahil et / Include Non-Key Columns)</span>
<span class="kw">CREATE INDEX</span> idx_orders_customer_covering
<span class="kw">ON</span> orders (customer_id, order_date <span class="kw">DESC</span>)
<span class="kw">INCLUDE</span> (total_amount);

<span class="co">-- Alternatif: Tum sutunlar indeks anahtarinda (All Columns in Index Key)</span>
<span class="kw">CREATE INDEX</span> idx_orders_customer_covering_alt
<span class="kw">ON</span> orders (customer_id, order_date <span class="kw">DESC</span>, total_amount);</code></pre>

                        <p><strong>Neden calisiyor (Why it works):</strong></p>
                        <ul>
                            <li><code>customer_id</code> - Esitlik filtresi (Equality Filter) icin ilk anahtar</li>
                            <li><code>order_date DESC</code> - Siralama (Sorting) icin ikinci anahtar (zaten sirada!)</li>
                            <li><code>total_amount</code> - Tablo erisimi (Table Access) gerekmemesi icin dahil edilmis (Included)</li>
                        </ul>

                        <div class="plan-output plan-good">
<pre>Index Only Scan using idx_orders_customer_covering
  (cost=0.43..12.56 rows=10 width=16)
  Index Cond: (customer_id = 12345)
  Heap Fetches: 0  <-- Tablo erisimi yok! (No Table Access!)</pre>
                        </div>

                        <div class="concept-box">
                            <strong>INCLUDE vs Anahtar Sutunlar (INCLUDE vs Key Columns):</strong><br>
                            Yalnizca SELECT'te gereken sutunlar icin <code>INCLUDE</code> kullanin (WHERE/ORDER BY'da kullanilmayan). Bu, indeks agacini (Index Tree) daha kucuk ve hizli tutar.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Alistirma 2.4: Ifade Indeksi (Expression Index)</h4>
                    <p>Kullanicilar e-posta ile musteri arar, ancak arama buyuk/kucuk harf duyarsizdir (Case-Insensitive):</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Mevcut yavas sorgu</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers
<span class="kw">WHERE</span> <span class="fu">LOWER</span>(email) = <span class="st">'john.doe@example.com'</span>;</code></pre>

                    <p><code>email</code> uzerindeki normal bir indeks (Index), <code>LOWER()</code> fonksiyonu nedeniyle yardimci olmaz.</p>

                    <p><strong>Gorev:</strong> Bu buyuk/kucuk harf duyarsiz (Case-Insensitive) aramayi destekleyen bir indeks olusturun.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol2_4')">Cozumu Goster</button>
                    <div id="sol2_4" class="solution-content">
                        <p><strong>Cozum - Ifade Indeksi (Expression Index):</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- PostgreSQL ifade indeksi (Expression Index)</span>
<span class="kw">CREATE INDEX</span> idx_customers_email_lower
<span class="kw">ON</span> customers (<span class="fu">LOWER</span>(email));

<span class="co">-- Sorgu ayni ifadeyi kullanmalidir:</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers
<span class="kw">WHERE</span> <span class="fu">LOWER</span>(email) = <span class="fu">LOWER</span>(<span class="st">'John.Doe@Example.com'</span>);</code></pre>

                        <p><strong>Alternatif yaklasimlar (Alternative Approaches):</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- PostgreSQL: Buyuk/kucuk harf duyarsiz metin icin citext uzantisi kullanin (Use citext extension)</span>
<span class="kw">CREATE EXTENSION IF NOT EXISTS</span> citext;
<span class="kw">ALTER TABLE</span> customers <span class="kw">ALTER COLUMN</span> email <span class="kw">TYPE</span> citext;
<span class="co">-- Simdi normal indeks calisiyor: WHERE email = 'John.Doe@Example.com'</span>

<span class="co">-- SQL Server: Buyuk/kucuk harf duyarsiz collation kullanin (Use Case-Insensitive Collation)</span>
<span class="kw">CREATE INDEX</span> idx_customers_email <span class="kw">ON</span> customers (email);
<span class="co">-- Varsayilan collation genellikle buyuk/kucuk harf duyarsizdir (Default collation is usually case-insensitive)</span></code></pre>

                        <div class="warning-box">
                            <strong>Onemli (Important):</strong> Sorgu, indeksle TAMAMEN ayni ifadeyi (Expression) kullanmalidir.
                            <code>WHERE UPPER(email) = ...</code> bu indeksi KULLANMAZ!
                        </div>
                    </div>
                </div>
            </section>

            <!-- Bolum 3: Sorgu Yeniden Yazma -->
            <section>
                <h2>Bolum 3: Performans Icin Sorgu Yeniden Yazma (Query Rewriting for Performance)</h2>
                <p>Yavas sorgulari optimize edilmis versiyonlara (Optimized Versions) donusturun.</p>

                <div class="exercise-box">
                    <h4>Alistirma 3.1: Indeksli Sutunlarda Fonksiyonlardan Kacinma (Avoiding Functions on Indexed Columns)</h4>
                    <p>Bu sorgu, <code>order_date</code> uzerinde indeks (Index) olmasina ragmen yavas calisiyor:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Yavas sorgu (indeks kullanilamaz)</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> orders
<span class="kw">WHERE</span> <span class="fu">YEAR</span>(order_date) = <span class="dv">2024</span>;</code></pre>

                    <p><strong>Gorev:</strong> <code>order_date</code> uzerindeki indeksi (Index) kullanmak icin sorguyu yeniden yazin (Rewrite).</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol3_1')">Cozumu Goster</button>
                    <div id="sol3_1" class="solution-content">
                        <p><strong>Optimize Edilmis Sorgu (Optimized Query):</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Fonksiyon yerine aralik kosulu kullanin (Use Range Condition Instead of Function)</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> orders
<span class="kw">WHERE</span> order_date >= <span class="st">'2024-01-01'</span>
  <span class="kw">AND</span> order_date < <span class="st">'2025-01-01'</span>;</code></pre>

                        <table class="comparison-table">
                            <tr>
                                <td class="slow" style="width: 50%;">
                                    <strong>Once (Yavas / Before - Slow):</strong>
                                    <div class="plan-output plan-bad">
<pre>Seq Scan on orders
cost=0.00..55123.00
Filter: YEAR(order_date) = 2024</pre>
                                    </div>
                                </td>
                                <td class="fast" style="width: 50%;">
                                    <strong>Sonra (Hizli / After - Fast):</strong>
                                    <div class="plan-output plan-good">
<pre>Index Scan using idx_orders_date
cost=0.43..8456.00
Index Cond: (order_date >= ... AND ...)</pre>
                                    </div>
                                </td>
                            </tr>
                        </table>

                        <p><strong>Daha fazla ornek (More Examples):</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Kotu (Bad): Sutunda fonksiyon (Function on Column)</span>
<span class="kw">WHERE</span> <span class="fu">DATE</span>(created_at) = <span class="st">'2024-06-15'</span>
<span class="co">-- Iyi (Good): Aralik kosulu (Range Condition)</span>
<span class="kw">WHERE</span> created_at >= <span class="st">'2024-06-15'</span> <span class="kw">AND</span> created_at < <span class="st">'2024-06-16'</span>

<span class="co">-- Kotu (Bad): Sutunda hesaplama (Calculation on Column)</span>
<span class="kw">WHERE</span> total_amount * <span class="fl">1.1</span> > <span class="dv">100</span>
<span class="co">-- Iyi (Good): Hesaplamayi sabite tasiyin (Move Calculation to Constant)</span>
<span class="kw">WHERE</span> total_amount > <span class="dv">100</span> / <span class="fl">1.1</span>

<span class="co">-- Kotu (Bad): String fonksiyonu (String Function)</span>
<span class="kw">WHERE</span> <span class="fu">SUBSTRING</span>(code, <span class="dv">1</span>, <span class="dv">3</span>) = <span class="st">'ABC'</span>
<span class="co">-- Iyi (Good): Onek ile LIKE kullanin (Use LIKE with Prefix)</span>
<span class="kw">WHERE</span> code <span class="kw">LIKE</span> <span class="st">'ABC%'</span></code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Alistirma 3.2: Iliskili Alt Sorguyu (Correlated Subquery) JOIN ile Degistirme</h4>
                    <p>Bu sorgu, musterilerin en son siparislerini bulur, ancak cok yavas calisiyor:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Yavas: Iliskili alt sorgu (Correlated Subquery) (her musteri icin bir kez calisir)</span>
<span class="kw">SELECT</span>
    c.customer_id,
    c.email,
    (
        <span class="kw">SELECT</span> <span class="fu">MAX</span>(o.order_date)
        <span class="kw">FROM</span> orders o
        <span class="kw">WHERE</span> o.customer_id = c.customer_id
    ) <span class="kw">AS</span> last_order_date
<span class="kw">FROM</span> customers c
<span class="kw">WHERE</span> c.is_active = <span class="kw">TRUE</span>;</code></pre>

                    <p><strong>Gorev:</strong> Daha iyi performans icin JOIN kullanarak yeniden yazin (Rewrite Using JOIN).</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol3_2')">Cozumu Goster</button>
                    <div id="sol3_2" class="solution-content">
                        <p><strong>JOIN Kullanilarak Optimize Edilmis Sorgu (Optimized Query Using JOIN):</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Hizli: JOIN ile tek toplama (Single Aggregation with JOIN)</span>
<span class="kw">SELECT</span>
    c.customer_id,
    c.email,
    <span class="fu">MAX</span>(o.order_date) <span class="kw">AS</span> last_order_date
<span class="kw">FROM</span> customers c
<span class="kw">LEFT JOIN</span> orders o <span class="kw">ON</span> c.customer_id = o.customer_id
<span class="kw">WHERE</span> c.is_active = <span class="kw">TRUE</span>
<span class="kw">GROUP BY</span> c.customer_id, c.email;</code></pre>

                        <p><strong>Window Function (Pencere Fonksiyonu) Kullanan Alternatif (tam siparis detaylarini alin):</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Gercek en son siparisi alin, sadece tarihi degil (Get Actual Latest Order)</span>
<span class="kw">WITH</span> ranked_orders <span class="kw">AS</span> (
    <span class="kw">SELECT</span>
        o.*,
        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (
            <span class="kw">PARTITION BY</span> o.customer_id
            <span class="kw">ORDER BY</span> o.order_date <span class="kw">DESC</span>
        ) <span class="kw">AS</span> rn
    <span class="kw">FROM</span> orders o
)
<span class="kw">SELECT</span>
    c.customer_id,
    c.email,
    ro.order_date <span class="kw">AS</span> last_order_date,
    ro.total_amount <span class="kw">AS</span> last_order_amount
<span class="kw">FROM</span> customers c
<span class="kw">LEFT JOIN</span> ranked_orders ro
    <span class="kw">ON</span> c.customer_id = ro.customer_id <span class="kw">AND</span> ro.rn = <span class="dv">1</span>
<span class="kw">WHERE</span> c.is_active = <span class="kw">TRUE</span>;</code></pre>

                        <div class="concept-box">
                            <strong>Performans Karsilastirmasi (Performance Comparison):</strong><br>
                            <ul class="mb-0">
                                <li>Iliskili alt sorgu (Correlated Subquery): O(musteriler x siparisler) - HER musteri icin alt sorgu calistirir</li>
                                <li>JOIN yaklasimi (JOIN Approach): O(musteriler + siparisler) - her tablodan tek gecis (Single Pass)</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Alistirma 3.3: EXISTS vs IN vs JOIN Karsilastirmasi</h4>
                    <p>En az bir siparis vermis tum musterileri bulun. Uc yaklasimi karsilastirin:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Yaklasim 1: IN alt sorgusu</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers
<span class="kw">WHERE</span> customer_id <span class="kw">IN</span> (<span class="kw">SELECT</span> customer_id <span class="kw">FROM</span> orders);

<span class="co">-- Yaklasim 2: EXISTS alt sorgusu</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers c
<span class="kw">WHERE</span> <span class="kw">EXISTS</span> (<span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">FROM</span> orders o <span class="kw">WHERE</span> o.customer_id = c.customer_id);

<span class="co">-- Yaklasim 3: DISTINCT ile JOIN</span>
<span class="kw">SELECT DISTINCT</span> c.* <span class="kw">FROM</span> customers c
<span class="kw">JOIN</span> orders o <span class="kw">ON</span> c.customer_id = o.customer_id;</code></pre>

                    <p><strong>Gorev:</strong> Hangi yaklaşimin en iyi oldugunu ve ne zaman oldugunu analiz edin.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol3_3')">Cozumu Goster</button>
                    <div id="sol3_3" class="solution-content">
                        <p><strong>Analiz:</strong></p>

                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Yaklasim</th>
                                    <th>En Iyi Durum</th>
                                    <th>Performans</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>EXISTS</code></td>
                                    <td>Buyuk orders tablosu, sadece varlik kontrolu</td>
                                    <td>Ilk esleşmede durur (erken sonlandirma)</td>
                                </tr>
                                <tr>
                                    <td><code>IN</code></td>
                                    <td>Kucuk alt sorgu sonuc kumesi</td>
                                    <td>Once tam listeyi olusturmalidir</td>
                                </tr>
                                <tr>
                                    <td><code>JOIN + DISTINCT</code></td>
                                    <td>Her iki tablodan sutunlara ihtiyac duyuldugunda</td>
                                    <td>Tekrar kaldirma icin ekstra is</td>
                                </tr>
                            </tbody>
                        </table>

                        <p><strong>Bu ozel durum icin oneri:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- EXISTS genellikle varlik kontrolleri icin en iyisidir</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers c
<span class="kw">WHERE</span> <span class="kw">EXISTS</span> (
    <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">FROM</span> orders o
    <span class="kw">WHERE</span> o.customer_id = c.customer_id
);</code></pre>

                        <p><strong>Tum yaklasimlar icin gerekli indeks:</strong></p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_customer_id <span class="kw">ON</span> orders (customer_id);</code></pre>

                        <div class="hint-box">
                            <strong>Modern Optimize Ediciler:</strong> Cogu modern veritabani (PostgreSQL 12+, SQL Server 2019+) genellikle IN ve EXISTS'i benzer planlar uretecek sekilde optimize edebilir. Her zaman EXPLAIN ile dogrulayin.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Alistirma 3.4: UNION ALL vs UNION</h4>
                    <p>Aktif ve VIP musterileri birlestirmeniz gerekiyor (VIP ayri bir bayraktir):</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Mevcut yavas sorgu</span>
<span class="kw">SELECT</span> customer_id, email, <span class="st">'active'</span> <span class="kw">AS</span> source
<span class="kw">FROM</span> customers <span class="kw">WHERE</span> is_active = <span class="kw">TRUE</span>
<span class="kw">UNION</span>
<span class="kw">SELECT</span> customer_id, email, <span class="st">'vip'</span> <span class="kw">AS</span> source
<span class="kw">FROM</span> customers <span class="kw">WHERE</span> is_vip = <span class="kw">TRUE</span>;</code></pre>

                    <p><strong>Gorev:</strong> Ayni musterinin hem aktif hem de VIP olabilecegini bilerek bu sorguyu optimize edin (ve bu durumda her iki satiri da gormek istiyorsunuz).</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol3_4')">Cozumu Goster</button>
                    <div id="sol3_4" class="solution-content">
                        <p><strong>Optimize Edilmis Sorgu:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Tekrarlar kasitli oldugu icin UNION ALL kullanin</span>
<span class="kw">SELECT</span> customer_id, email, <span class="st">'active'</span> <span class="kw">AS</span> source
<span class="kw">FROM</span> customers <span class="kw">WHERE</span> is_active = <span class="kw">TRUE</span>
<span class="kw">UNION ALL</span>
<span class="kw">SELECT</span> customer_id, email, <span class="st">'vip'</span> <span class="kw">AS</span> source
<span class="kw">FROM</span> customers <span class="kw">WHERE</span> is_vip = <span class="kw">TRUE</span>;</code></pre>

                        <table class="comparison-table">
                            <tr>
                                <td class="slow">
                                    <strong>UNION (Yavas):</strong>
                                    <ul>
                                        <li>Sonuclari birlestirir</li>
                                        <li>Tum satirlari siralar</li>
                                        <li>Tekrarlari kaldirir</li>
                                    </ul>
                                </td>
                                <td class="fast">
                                    <strong>UNION ALL (Hizli):</strong>
                                    <ul>
                                        <li>Sonuclari birlestirir</li>
                                        <li>Tamamlandi!</li>
                                        <li>&nbsp;</li>
                                    </ul>
                                </td>
                            </tr>
                        </table>

                        <div class="warning-box">
                            <strong>UNION (ALL degil) ne zaman kullanilir:</strong><br>
                            UNION'i yalnizca ozellikle tekrarlari kaldirmaniz gerektiginde ve sorgular ayni satirlari dondurebileceginde kullanin. Sorgular karsilikli olarak ozel ise veya tum satirlari istiyorsaniz, UNION ALL kullanin.
                        </div>
                    </div>
                </div>
            </section>

            <!-- Bolum 4: Zorluk Alistirmalari -->
            <section>
                <h2>Bolum 4: Zorluk Alistirmalari</h2>
                <p>Birden fazla optimizasyon teknigini birlestiren karmasik senaryolar.</p>

                <div class="exercise-box">
                    <h4>Zorluk 4.1: Bir Raporlama Sorgusunu Optimize Etme</h4>
                    <p>Bu aylik satis raporu 45 saniye calisiyor. Optimize edin:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Mevcut yavas sorgu</span>
<span class="kw">SELECT</span>
    c.name <span class="kw">AS</span> category,
    <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, o.order_date) <span class="kw">AS</span> month,
    <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> o.id) <span class="kw">AS</span> order_count,
    <span class="fu">SUM</span>(ol.line_total) <span class="kw">AS</span> revenue
<span class="kw">FROM</span> sales.orders o
<span class="kw">JOIN</span> sales.order_lines ol <span class="kw">ON</span> o.id = ol.order_id
<span class="kw">JOIN</span> sales.products p <span class="kw">ON</span> ol.product_id = p.id
<span class="kw">JOIN</span> sales.categories c <span class="kw">ON</span> p.category_id = c.id
<span class="kw">WHERE</span> o.order_date >= <span class="st">'2024-01-01'</span>
  <span class="kw">AND</span> o.status <span class="kw">IN</span> (<span class="st">'delivered'</span>, <span class="st">'shipped'</span>)
<span class="kw">GROUP BY</span> c.name, <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, o.order_date)
<span class="kw">ORDER BY</span> month, revenue <span class="kw">DESC</span>;</code></pre>

                    <p><strong>Gorev:</strong> Yurutme suresini azaltmak icin optimizasyonlari (indeksler, sorgu yeniden yazmalari) tanimlayin.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol4_1')">Cozumu Goster</button>
                    <div id="sol4_1" class="solution-content">
                        <p><strong>Adim 1: Destekleyici Indeksler Olusturun</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Siparis filtreleme ve birlestirme icin indeks</span>
<span class="kw">CREATE INDEX</span> idx_orders_date_status
<span class="kw">ON</span> sales.orders (order_date, status)
<span class="kw">WHERE</span> status <span class="kw">IN</span> (<span class="st">'delivered'</span>, <span class="st">'shipped'</span>);

<span class="co">-- order_lines join icin indeks</span>
<span class="kw">CREATE INDEX</span> idx_order_lines_order_id
<span class="kw">ON</span> sales.order_lines (order_id)
<span class="kw">INCLUDE</span> (product_id, line_total);

<span class="co">-- products join icin indeks</span>
<span class="kw">CREATE INDEX</span> idx_products_id_category
<span class="kw">ON</span> sales.products (id)
<span class="kw">INCLUDE</span> (category_id);</code></pre>

                        <p><strong>Adim 2: Sorgu Optimizasyonu</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Daha iyi plan icin CTE kullanan optimize edilmis sorgu</span>
<span class="kw">WITH</span> filtered_orders <span class="kw">AS</span> (
    <span class="kw">SELECT</span> id, order_date
    <span class="kw">FROM</span> sales.orders
    <span class="kw">WHERE</span> order_date >= <span class="st">'2024-01-01'</span>
      <span class="kw">AND</span> status <span class="kw">IN</span> (<span class="st">'delivered'</span>, <span class="st">'shipped'</span>)
)
<span class="kw">SELECT</span>
    c.name <span class="kw">AS</span> category,
    <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, fo.order_date) <span class="kw">AS</span> month,
    <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> fo.id) <span class="kw">AS</span> order_count,
    <span class="fu">SUM</span>(ol.line_total) <span class="kw">AS</span> revenue
<span class="kw">FROM</span> filtered_orders fo
<span class="kw">JOIN</span> sales.order_lines ol <span class="kw">ON</span> fo.id = ol.order_id
<span class="kw">JOIN</span> sales.products p <span class="kw">ON</span> ol.product_id = p.id
<span class="kw">JOIN</span> sales.categories c <span class="kw">ON</span> p.category_id = c.id
<span class="kw">GROUP BY</span> c.name, <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, fo.order_date)
<span class="kw">ORDER BY</span> month, revenue <span class="kw">DESC</span>;</code></pre>

                        <p><strong>Adim 3: Sik Raporlar Icin Materialized View Dusunun</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Bu rapor sik calisiyorsa, onceden hesaplayin</span>
<span class="kw">CREATE MATERIALIZED VIEW</span> mv_monthly_sales <span class="kw">AS</span>
<span class="kw">SELECT</span>
    c.name <span class="kw">AS</span> category,
    <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, o.order_date) <span class="kw">AS</span> month,
    <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> o.id) <span class="kw">AS</span> order_count,
    <span class="fu">SUM</span>(ol.line_total) <span class="kw">AS</span> revenue
<span class="kw">FROM</span> sales.orders o
<span class="kw">JOIN</span> sales.order_lines ol <span class="kw">ON</span> o.id = ol.order_id
<span class="kw">JOIN</span> sales.products p <span class="kw">ON</span> ol.product_id = p.id
<span class="kw">JOIN</span> sales.categories c <span class="kw">ON</span> p.category_id = c.id
<span class="kw">WHERE</span> o.status <span class="kw">IN</span> (<span class="st">'delivered'</span>, <span class="st">'shipped'</span>)
<span class="kw">GROUP BY</span> c.name, <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, o.order_date);

<span class="co">-- Gunluk yenile</span>
<span class="kw">REFRESH MATERIALIZED VIEW</span> mv_monthly_sales;</code></pre>

                        <div class="concept-box">
                            <strong>Beklenen Iyilestirme:</strong> Indekslerle 45 saniye -> 2-5 saniye, veya materialized view ile saniyenin altinda.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Zorluk 4.2: Sayfalama Performansi</h4>
                    <p>Bu sayfalama sorgusu, kullanicilar sonraki sayfalara gittikce yavaslıyor:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Buyuk offset'ler icin yavas (ornegin, sayfa 1000)</span>
<span class="kw">SELECT</span> order_id, order_date, total_amount
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">20</span> <span class="kw">OFFSET</span> <span class="dv">19980</span>;  <span class="co">-- Sayfa 1000 x sayfa basina 20</span></code></pre>

                    <p><strong>Gorev:</strong> Alternatif olarak keyset (cursor tabanli) sayfalama uygulayin.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol4_2')">Cozumu Goster</button>
                    <div id="sol4_2" class="solution-content">
                        <p><strong>OFFSET'in Sorunu:</strong></p>
                        <ul>
                            <li>Veritabani 20 dondurmeden once 19.980 satiri taramali ve atmalidir</li>
                            <li>Performans sayfa numarasiyla dogrusal olarak duser</li>
                        </ul>

                        <p><strong>Cozum: Keyset Sayfalama</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Ilk sayfa</span>
<span class="kw">SELECT</span> order_id, order_date, total_amount
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>, order_id <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">20</span>;

<span class="co">-- Sonraki sayfalar: son satirin degerlerini cursor olarak kullanin</span>
<span class="co">-- Son satir: order_date='2024-03-15', order_id=98765 ise</span>
<span class="kw">SELECT</span> order_id, order_date, total_amount
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
  <span class="kw">AND</span> (order_date, order_id) < (<span class="st">'2024-03-15'</span>, <span class="dv">98765</span>)
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>, order_id <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">20</span>;</code></pre>

                        <p><strong>Destekleyici Indeks:</strong></p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_customer_date_id
<span class="kw">ON</span> orders (customer_id, order_date <span class="kw">DESC</span>, order_id <span class="kw">DESC</span>);</code></pre>

                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Metrik</th>
                                    <th>OFFSET (Sayfa 1000)</th>
                                    <th>Keyset</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Taranan satirlar</td>
                                    <td>~20.000</td>
                                    <td>~20</td>
                                </tr>
                                <tr>
                                    <td>Yurutme suresi</td>
                                    <td>~500ms</td>
                                    <td>~1ms</td>
                                </tr>
                                <tr>
                                    <td>Tutarlilik</td>
                                    <td>Veri degisirse kacirma/coklatma olabilir</td>
                                    <td>Stabil cursor konumu</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="warning-box">
                            <strong>Takas:</strong> Keyset sayfalama dogrudan "sayfa N'ye git"i desteklemez. Sonsuz kaydirma veya "daha fazla yukle" kaliplari icin en iyisidir.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Zorluk 4.3: Sorgu Plani Analizi</h4>
                    <p>Bu EXPLAIN ANALYZE ciktisini analiz edin ve tum sorunlari tanimlayin:</p>

                    <div class="plan-output plan-bad">
<pre>EXPLAIN ANALYZE
SELECT c.email, COUNT(o.order_id) as order_count, SUM(o.total_amount) as total_spent
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
WHERE LOWER(c.email) LIKE '%gmail.com'
  AND o.order_date >= '2024-01-01'
GROUP BY c.email
HAVING SUM(o.total_amount) > 1000;

HashAggregate  (cost=125678.00..125789.00 rows=1000 width=48) (actual time=8234.567..8236.789 rows=156 loops=1)
  Group Key: c.email
  Filter: (sum(o.total_amount) > 1000)
  Rows Removed by Filter: 12456
  ->  Hash Join  (cost=15234.00..98765.00 rows=250000 width=48) (actual time=1234.567..7890.123 rows=456789 loops=1)
        Hash Cond: (o.customer_id = c.customer_id)
        ->  Seq Scan on orders o  (cost=0.00..45123.00 rows=500000 width=20) (actual time=0.012..2345.678 rows=485632 loops=1)
              Filter: (order_date >= '2024-01-01')
              Rows Removed by Filter: 1514368
        ->  Hash  (cost=12456.00..12456.00 rows=50000 width=36) (actual time=1234.123..1234.123 rows=48765 loops=1)
              ->  Seq Scan on customers c  (cost=0.00..12456.00 rows=50000 width=36) (actual time=0.023..1123.456 rows=48765 loops=1)
                    Filter: (lower((email)::text) ~~ '%gmail.com'::text)
                    Rows Removed by Filter: 451235

Planning Time: 0.456 ms
Execution Time: 8237.890 ms</pre>
                    </div>

                    <p><strong>Gorev:</strong> Tum performans sorunlarini listeleyin ve cozumler sunun.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol4_3')">Cozumu Goster</button>
                    <div id="sol4_3" class="solution-content">
                        <p><strong>Tanimlanan Sorunlar:</strong></p>

                        <ol>
                            <li>
                                <strong>E-postada basta joker karakter LIKE</strong>
                                <br><code>LOWER(c.email) LIKE '%gmail.com'</code>
                                <br>Basta % ve fonksiyon nedeniyle indeks kullanilamaz
                                <br><em>Cozum:</em> Domain ariyorsaniz, veriyi yeniden yapilandirin veya tam metin aramasi kullanin
                                <pre><code class="sourceCode sql"><span class="co">-- Domain sutunu ekleyin veya pg_trgm kullanin</span>
<span class="kw">CREATE EXTENSION</span> pg_trgm;
<span class="kw">CREATE INDEX</span> idx_customers_email_trgm
<span class="kw">ON</span> customers <span class="kw">USING</span> gin (email gin_trgm_ops);</code></pre>
                            </li>

                            <li>
                                <strong>orders uzerinde sequential scan</strong>
                                <br>2M satir taranip 485K'ya filtreleniyor
                                <br><em>Cozum:</em> order_date uzerinde indeks
                                <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_date <span class="kw">ON</span> orders (order_date);</code></pre>
                            </li>

                            <li>
                                <strong>Join icin eksik indeks</strong>
                                <br>Hash join makul ama indeks yardimci olabilir
                                <br><em>Cozum:</em> customer_id uzerinde indeks
                                <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_customer <span class="kw">ON</span> orders (customer_id);</code></pre>
                            </li>

                            <li>
                                <strong>HAVING ile gec filtreleme</strong>
                                <br>456K satir isler, 12K'ya gruplar, sonra 156'ya filtreler
                                <br><em>Cozum:</em> Dogrudan duzeltme yok, ancak yuksek degerli musterileri onceden toplamak yardimci olabilir
                            </li>

                            <li>
                                <strong>Sag tabloda WHERE ile LEFT JOIN</strong>
                                <br><code>LEFT JOIN ... WHERE o.order_date >= ...</code> INNER JOIN'e donusur
                                <br><em>Cozum:</em> Acik olun - INNER JOIN kullanin veya filtreyi ON clause'a tasiyin
                            </li>
                        </ol>

                        <p><strong>Optimize Edilmis Sorgu:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Gerekli indeksler olusturulduktan sonra</span>
<span class="kw">SELECT</span> c.email, <span class="fu">COUNT</span>(o.order_id), <span class="fu">SUM</span>(o.total_amount)
<span class="kw">FROM</span> customers c
<span class="kw">INNER JOIN</span> orders o <span class="kw">ON</span> c.customer_id = o.customer_id
<span class="kw">WHERE</span> c.email <span class="kw">LIKE</span> <span class="st">'%@gmail.com'</span>  <span class="co">-- veya trigram indeksi kullanin</span>
  <span class="kw">AND</span> o.order_date >= <span class="st">'2024-01-01'</span>
<span class="kw">GROUP BY</span> c.email
<span class="kw">HAVING</span> <span class="fu">SUM</span>(o.total_amount) > <span class="dv">1000</span>;</code></pre>
                    </div>
                </div>
            </section>

            <!-- Onemli Cikarimlar -->
            <section>
                <h3>Onemli Cikarimlar</h3>
                <table class="table table-bordered">
                    <thead>
                        <tr>
                            <th>Konu</th>
                            <th>Ana Noktalar</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Yurutme Planlari</strong></td>
                            <td>
                                <ul class="mb-0">
                                    <li>Gercek vs tahmini satirlari gormek icin EXPLAIN ANALYZE kullanin</li>
                                    <li>Buyuk tablolarda Seq Scan'lere dikkat edin</li>
                                    <li>Buyuk tahmin/gercek farkliliklari eski istatistikleri gosterir</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Indeks Tasarimi</strong></td>
                            <td>
                                <ul class="mb-0">
                                    <li>Bilesik indeksler: once esitlik sutunlari, sonra aralik</li>
                                    <li>Sik filtrelenen alt kumeler icin kismi indeksler kullanin</li>
                                    <li>Kapsayici indeksler tablo aramalarini ortadan kaldirir</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Sorgu Yazimi</strong></td>
                            <td>
                                <ul class="mb-0">
                                    <li>WHERE'de indeksli sutunlarda fonksiyonlardan kacinin</li>
                                    <li>Iliskili alt sorgulari JOIN'lerle degistirin</li>
                                    <li>Tekrarlar onemli degilse UNION ALL kullanin</li>
                                    <li>Buyuk sonuc kumeleri icin keyset sayfalama kullanin</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Optimizasyon Sureci</strong></td>
                            <td>
                                <ul class="mb-0">
                                    <li>Once EXPLAIN ANALYZE ile olcun</li>
                                    <li>En yavas islemi tanimlayin</li>
                                    <li>Hedefli duzeltme uygulayin (indeks veya yeniden yazma)</li>
                                    <li>EXPLAIN ANALYZE ile iyilestirmeyi dogrulayin</li>
                                </ul>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Navigasyon -->
            <section>
                <div class="d-flex justify-content-between">
                    <a href="01_query_performance_and_optimization_tr.html" class="btn btn-outline-primary">&larr; Derse Don</a>
                </div>
            </section>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>

    <script>
        function toggleSolution(id) {
            var element = document.getElementById(id);
            if (element.classList.contains('show')) {
                element.classList.remove('show');
                event.target.textContent = 'Cozumu Goster';
            } else {
                element.classList.add('show');
                event.target.textContent = 'Cozumu Gizle';
            }
        }
    </script>
</body>

</html>
