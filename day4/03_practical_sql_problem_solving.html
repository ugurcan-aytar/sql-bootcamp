<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="../style_bootstrap.html">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/code.css">
    <link href="https://cdn.prod.website-files.com/5efdb54f07a6812bcd95cc65/6773d0fc3013e060f08d7145_favicon.jpg"
        rel="shortcut icon" type="image/x-icon">
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Day 4: Practical SQL Problem Solving</title>
    <style>
        code { white-space: pre-wrap; }
        .language-switcher {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .language-switcher a {
            text-decoration: none;
            padding: 5px 10px;
            margin: 0 2px;
            border-radius: 3px;
            color: #333;
        }
        .language-switcher a.active {
            background: #0d6efd;
            color: #fff;
        }
        .language-switcher a:hover:not(.active) {
            background: #e9ecef;
        }
        .pattern-box {
            background-color: #e7f3ff;
            border: 1px solid #0d6efd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .warning-box {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .tip-box {
            background-color: #d4edda;
            border: 1px solid #28a745;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .use-case {
            background-color: #f8f9fa;
            border-left: 4px solid #6c757d;
            padding: 10px 15px;
            margin: 10px 0;
        }
    </style>
</head>

<body>
    <a href="../index_en.html" class="back-button">&larr; Back to Index</a>
    <div class="language-switcher">
        <a href="03_practical_sql_problem_solving.html" class="active">EN</a>
        <a href="03_practical_sql_problem_solving_tr.html">TR</a>
    </div>
    <div class="copy-notification" id="copyNotification">Copied!</div>

    <div id="europeanunion-turkey">
        <img src="../static/eu.png" alt="">
    </div>
    <div id="sanayiteknolojibakan">
        <img src="../static/sanayitek.png" alt="">
    </div>
    <div id="rekabet">
        <img src="../static/rekabet.png" alt="">
    </div>
    <div id="tisk">
        <img src="../static/tisk.png" alt="">
    </div>
    <div id="undp">
        <img src="../static/undp.png" alt="">
    </div>
    <div class="content-container">
        <div class="container">
            <section>
                <h1 id="practical-sql">Part 4: Practical SQL Problem Solving</h1>
                <h2 id="common-patterns">Common SQL Patterns for Real-World Problems</h2>
                <p>This session covers essential SQL problem-solving patterns that engineers frequently encounter
                   in real-world scenarios. These patterns are commonly asked in technical interviews and are
                   fundamental for effective database querying.</p>

                <p><strong>Topics Covered:</strong></p>
                <ul>
                    <li>Recursive CTEs for Hierarchical Data</li>
                    <li>Top-N per Group Queries</li>
                    <li>Gap and Island Problems</li>
                    <li>Data Pivoting (Rows to Columns)</li>
                    <li>Deduplication Patterns</li>
                    <li>Date Range and Overlap Detection</li>
                </ul>
            </section>

            <!-- Section 1: Recursive CTEs -->
            <section>
                <h2 id="recursive-ctes">1. Recursive CTEs for Hierarchical Data</h2>

                <div class="pattern-box">
                    <strong>ðŸ’¡ Key Concept: What is a Recursive CTE?</strong><br>
                    <p style="margin-bottom: 0;">A Recursive CTE is a CTE that references itself. While normal CTEs run only once, recursive CTEs execute repeatedly until a termination condition is met. This allows us to traverse tree-structured or hierarchical data (e.g., employee-manager relationships, category trees) in a single query.</p>
                </div>

                <p>Recursive Common Table Expressions (CTEs) allow you to query hierarchical or tree-structured data,
                   such as organizational charts, category trees, or bill of materials.</p>

                <h3>Understanding Recursive CTE Structure</h3>
                <p>A recursive CTE has two parts:</p>
                <ol>
                    <li><strong>Anchor Member:</strong> The starting point (base case)</li>
                    <li><strong>Recursive Member:</strong> References the CTE itself to build upon previous results</li>
                </ol>

                <div class="warning-box">
                    <strong>ðŸ“š Terminology:</strong><br>
                    <ul style="margin-bottom: 0;">
                        <li><strong>Anchor Member:</strong> The starting point of a recursive CTE. A query that selects the topmost elements in the hierarchy (e.g., CEO with no manager).</li>
                        <li><strong>Recursive Member:</strong> The query that references the CTE itself and finds the next level in each iteration.</li>
                        <li><strong>UNION ALL:</strong> The operator that combines anchor and recursive results. It's mandatory in recursive CTEs.</li>
                    </ul>
                </div>

                <pre><code class="language-sql">-- Basic recursive CTE structure
WITH RECURSIVE cte_name AS (
    -- Anchor member: starting point
    SELECT columns
    FROM table
    WHERE condition  -- Usually: parent_id IS NULL or starting condition

    UNION ALL

    -- Recursive member: references itself
    SELECT columns
    FROM table t
    JOIN cte_name c ON t.parent_id = c.id  -- Links child to parent
)
SELECT * FROM cte_name;</code></pre>

                <h3>Example: Employee Hierarchy</h3>
                <p>Building an organizational chart using the <code>employees</code> table from bootcamp_db:</p>

                <pre><code class="language-sql">-- The employees table already has manager_id for hierarchy
-- SELECT id, first_name, last_name, job_title, manager_id FROM employees;

-- Recursive CTE to show full hierarchy with levels
WITH RECURSIVE org_chart AS (
    -- Anchor: Start with top-level managers (no manager)
    SELECT
        id,
        first_name || ' ' || last_name AS name,
        job_title,
        manager_id,
        1 AS level,
        first_name || ' ' || last_name AS path
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive: Find employees reporting to previous level
    SELECT
        e.id,
        e.first_name || ' ' || e.last_name,
        e.job_title,
        e.manager_id,
        oc.level + 1,
        oc.path || ' -> ' || e.first_name || ' ' || e.last_name
    FROM employees e
    JOIN org_chart oc ON e.manager_id = oc.id
)
SELECT
    REPEAT('  ', level - 1) || name AS employee,
    job_title,
    level,
    path
FROM org_chart
ORDER BY path;</code></pre>

                <div class="pattern-box">
                    <strong>Output (example):</strong>
                    <pre>employee              | job_title          | level | path
----------------------+--------------------+-------+---------------------------
John Smith            | CEO                | 1     | John Smith
  Sarah Johnson       | VP Engineering     | 2     | John Smith -> Sarah Johnson
    Mike Davis        | Engineering Manager| 3     | ... -> Mike Davis
      Tom Wilson      | Senior Developer   | 4     | ... -> Tom Wilson
  Emily Brown         | VP Sales           | 2     | John Smith -> Emily Brown
    Lisa Anderson     | Sales Manager      | 3     | ... -> Lisa Anderson</pre>
                </div>

                <h3>Example: Generating Number Sequences</h3>
                <p>Recursive CTEs can generate sequences without existing data:</p>

                <pre><code class="language-sql">-- Generate numbers 1 to 10
WITH RECURSIVE numbers AS (
    SELECT 1 AS n
    UNION ALL
    SELECT n + 1 FROM numbers WHERE n < 10
)
SELECT n FROM numbers;

-- Generate date series (alternative to generate_series)
WITH RECURSIVE date_range AS (
    SELECT DATE '2024-01-01' AS dt
    UNION ALL
    SELECT dt + INTERVAL '1 day'
    FROM date_range
    WHERE dt < DATE '2024-01-31'
)
SELECT dt FROM date_range;</code></pre>

                <div class="warning-box">
                    <strong>Warning:</strong> Always include a termination condition in recursive CTEs to prevent
                    infinite loops. PostgreSQL has a default limit, but it's best practice to explicitly control recursion depth.
                </div>

                <div class="use-case">
                    <strong>Real-World Use Cases:</strong>
                    <ul>
                        <li>Organizational charts and reporting structures</li>
                        <li>Product category trees (e.g., Electronics > Phones > Smartphones)</li>
                        <li>Bill of Materials (BOM) in manufacturing</li>
                        <li>File/folder hierarchies</li>
                        <li>Comment threads and replies</li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: Top-N per Group -->
            <section>
                <h2 id="top-n-per-group">2. Top-N per Group Queries</h2>

                <div class="pattern-box">
                    <strong>ðŸ’¡ Key Concept: Top-N Per Group</strong><br>
                    <p style="margin-bottom: 0;">The "top-N per group" problem appears in scenarios like getting top 3 products per category, or last 5 orders per customer. This is one of the most frequently asked SQL interview questions. Three approaches exist: ROW_NUMBER() (most flexible), DISTINCT ON (PostgreSQL-specific, top-1 only), and LATERAL JOIN (index-friendly).</p>
                </div>

                <p>A common requirement is to find the top N records within each group (e.g., top 3 products
                   per category, latest 5 orders per customer).</p>

                <h3>Method 1: ROW_NUMBER() Window Function</h3>
                <p>The most flexible and widely-used approach:</p>

                <pre><code class="language-sql">-- Top 3 most expensive products per category
WITH ranked_products AS (
    SELECT
        p.id,
        p.name,
        p.price,
        c.name AS category,
        ROW_NUMBER() OVER (
            PARTITION BY p.category_id
            ORDER BY p.price DESC
        ) AS rank_in_category
    FROM products p
    JOIN categories c ON p.category_id = c.id
    WHERE p.active = true
)
SELECT id, name, price, category, rank_in_category
FROM ranked_products
WHERE rank_in_category <= 3
ORDER BY category, rank_in_category;</code></pre>

                <h3>Method 2: DISTINCT ON (PostgreSQL-specific)</h3>

                <div class="warning-box">
                    <strong>ðŸ“š Term: DISTINCT ON</strong><br>
                    <p style="margin-bottom: 0;">DISTINCT ON is a PostgreSQL-specific feature. While regular DISTINCT looks at all columns, DISTINCT ON provides uniqueness based only on specified columns. It returns the first row per group according to ORDER BY. Suitable only for "Top-1" scenarios.</p>
                </div>

                <p>Simpler syntax for Top-1 per group:</p>

                <pre><code class="language-sql">-- Most recent order per customer (Top-1)
SELECT DISTINCT ON (customer_id)
    id,
    customer_id,
    order_date,
    total_amount
FROM orders
ORDER BY customer_id, order_date DESC;</code></pre>

                <div class="tip-box">
                    <strong>Tip:</strong> DISTINCT ON is PostgreSQL-specific and very efficient for Top-1 queries.
                    For Top-N (where N > 1), use the ROW_NUMBER() approach.
                </div>

                <h3>Method 3: LATERAL JOIN</h3>

                <div class="warning-box">
                    <strong>ðŸ“š Term: LATERAL JOIN</strong><br>
                    <p style="margin-bottom: 0;">LATERAL allows a subquery to reference other tables in the same FROM clause. Normal subqueries cannot do this. The subquery is re-executed for each row of the left table. This enables efficient index usage and can be faster than ROW_NUMBER() on large datasets.</p>
                </div>

                <p>Powerful approach that allows correlated subqueries in FROM clause:</p>

                <pre><code class="language-sql">-- Top 3 orders per customer using LATERAL
SELECT
    c.id AS customer_id,
    c.name AS customer_name,
    top_orders.id AS order_id,
    top_orders.order_date,
    top_orders.total_amount
FROM customers c
CROSS JOIN LATERAL (
    SELECT id, order_date, total_amount
    FROM orders o
    WHERE o.customer_id = c.id
    ORDER BY total_amount DESC
    LIMIT 3
) AS top_orders
ORDER BY c.id, top_orders.total_amount DESC;</code></pre>

                <h3>Comparing Approaches</h3>
                <table class="table table-bordered">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Best For</th>
                            <th>Pros</th>
                            <th>Cons</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ROW_NUMBER()</td>
                            <td>Any Top-N</td>
                            <td>Portable, flexible</td>
                            <td>Processes all rows first</td>
                        </tr>
                        <tr>
                            <td>DISTINCT ON</td>
                            <td>Top-1 only</td>
                            <td>Very fast, simple</td>
                            <td>PostgreSQL only, Top-1 only</td>
                        </tr>
                        <tr>
                            <td>LATERAL</td>
                            <td>Any Top-N</td>
                            <td>Can use indexes well</td>
                            <td>More complex syntax</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 3: Gap and Island Problems -->
            <section>
                <h2 id="gap-island">3. Gap and Island Problems</h2>

                <div class="pattern-box">
                    <strong>ðŸ’¡ Key Concept: Gap and Island Problem</strong><br>
                    <p style="margin-bottom: 0;">This classic SQL problem is about finding "gaps" (missing values) and "islands" (groups of consecutive values) in a sequence. For example: in sequence 1,2,3,5,6,10, numbers 4,7,8,9 are gaps; {1,2,3}, {5,6}, {10} are islands. The key technique: <code>value - ROW_NUMBER()</code> difference remains the same for consecutive values but changes at gaps.</p>
                </div>

                <p>Gap and Island problems involve finding consecutive sequences (islands) or missing values (gaps)
                   in data. These are classic SQL interview questions.</p>

                <h3>Understanding the Problem</h3>
                <p>Given a sequence with some missing values, identify:</p>
                <ul>
                    <li><strong>Gaps:</strong> Missing values in the sequence</li>
                    <li><strong>Islands:</strong> Consecutive ranges of existing values</li>
                </ul>

                <h3>Finding Gaps in Sequences</h3>
                <pre><code class="language-sql">-- Sample data: order IDs with gaps
CREATE TABLE order_ids (id INTEGER PRIMARY KEY);
INSERT INTO order_ids VALUES (1), (2), (3), (5), (6), (10), (11), (12), (15);

-- Find gaps in ID sequence
WITH id_with_next AS (
    SELECT
        id,
        LEAD(id) OVER (ORDER BY id) AS next_id
    FROM order_ids
)
SELECT
    id + 1 AS gap_start,
    next_id - 1 AS gap_end,
    next_id - id - 1 AS gap_size
FROM id_with_next
WHERE next_id - id > 1
ORDER BY id;

-- Result:
-- gap_start | gap_end | gap_size
-- ----------+---------+---------
--         4 |       4 |       1
--         7 |       9 |       3
--        13 |      14 |       2</code></pre>

                <h3>Finding Islands (Consecutive Groups)</h3>
                <pre><code class="language-sql">-- Find consecutive ranges (islands)
WITH grouped AS (
    SELECT
        id,
        id - ROW_NUMBER() OVER (ORDER BY id) AS grp
    FROM order_ids
)
SELECT
    MIN(id) AS island_start,
    MAX(id) AS island_end,
    COUNT(*) AS island_size
FROM grouped
GROUP BY grp
ORDER BY island_start;

-- Result:
-- island_start | island_end | island_size
-- -------------+------------+------------
--            1 |          3 |          3
--            5 |          6 |          2
--           10 |         12 |          3
--           15 |         15 |          1</code></pre>

                <div class="pattern-box">
                    <strong>How it works:</strong> The trick is that for consecutive numbers,
                    <code>value - ROW_NUMBER()</code> produces the same result. When there's a gap,
                    this difference changes, creating a new group.
                    <pre>
ID:  1  2  3  5  6  10 11 12 15
ROW: 1  2  3  4  5   6  7  8  9
DIFF:0  0  0  1  1   4  4  4  6  (groups consecutive values)
                    </pre>
                </div>

                <h3>Date-Based Islands: Finding Active Periods</h3>
                <pre><code class="language-sql">-- Find consecutive days with orders
WITH order_dates AS (
    SELECT DISTINCT DATE(order_date) AS order_day
    FROM orders
    ORDER BY order_day
),
grouped AS (
    SELECT
        order_day,
        order_day - (ROW_NUMBER() OVER (ORDER BY order_day))::INTEGER AS grp
    FROM order_dates
)
SELECT
    MIN(order_day) AS period_start,
    MAX(order_day) AS period_end,
    MAX(order_day) - MIN(order_day) + 1 AS consecutive_days
FROM grouped
GROUP BY grp
ORDER BY period_start;</code></pre>
            </section>

            <!-- Section 4: Data Pivoting -->
            <section>
                <h2 id="pivoting">4. Data Pivoting (Rows to Columns)</h2>

                <div class="pattern-box">
                    <strong>ðŸ’¡ Key Concept: Data Pivoting</strong><br>
                    <p style="margin-bottom: 0;">Pivoting is the process of transforming row data into columns. For example, converting monthly sales data from rows into columns like Jan, Feb, Mar... Similar to Excel's Pivot Table. Two methods in SQL: (1) CASE + SUM/COUNT (works in all databases), (2) FILTER clause (PostgreSQL-specific, cleaner syntax).</p>
                </div>

                <p>Pivoting transforms row data into columns, useful for creating summary reports and
                   cross-tabulations.</p>

                <h3>Method 1: CASE with Aggregation (Most Portable)</h3>
                <pre><code class="language-sql">-- Monthly sales pivot table
SELECT
    EXTRACT(YEAR FROM order_date) AS year,
    SUM(CASE WHEN EXTRACT(MONTH FROM order_date) = 1 THEN total_amount ELSE 0 END) AS jan,
    SUM(CASE WHEN EXTRACT(MONTH FROM order_date) = 2 THEN total_amount ELSE 0 END) AS feb,
    SUM(CASE WHEN EXTRACT(MONTH FROM order_date) = 3 THEN total_amount ELSE 0 END) AS mar,
    SUM(CASE WHEN EXTRACT(MONTH FROM order_date) = 4 THEN total_amount ELSE 0 END) AS apr,
    SUM(CASE WHEN EXTRACT(MONTH FROM order_date) = 5 THEN total_amount ELSE 0 END) AS may,
    SUM(CASE WHEN EXTRACT(MONTH FROM order_date) = 6 THEN total_amount ELSE 0 END) AS jun,
    -- ... continue for other months
    SUM(total_amount) AS total
FROM orders
GROUP BY EXTRACT(YEAR FROM order_date)
ORDER BY year;</code></pre>

                <h3>Method 2: FILTER Clause (PostgreSQL 9.4+)</h3>

                <div class="warning-box">
                    <strong>ðŸ“š Term: FILTER Clause</strong><br>
                    <p style="margin-bottom: 0;">The FILTER clause allows you to add conditional filtering to aggregate functions (SUM, COUNT, AVG, etc.). Used as <code>SUM(amount) FILTER (WHERE type = 'A')</code>. It's an alternative to CASE WHEN but more readable and less error-prone. Available in PostgreSQL 9.4+ and SQL:2003 standard.</p>
                </div>

                <p>Cleaner syntax using the FILTER clause:</p>

                <pre><code class="language-sql">-- Sales by category per customer type
SELECT
    c.name AS category,
    SUM(ol.quantity * ol.unit_price) FILTER (WHERE cu.customer_type = 'individual') AS individual_sales,
    SUM(ol.quantity * ol.unit_price) FILTER (WHERE cu.customer_type = 'business') AS business_sales,
    SUM(ol.quantity * ol.unit_price) FILTER (WHERE cu.customer_type = 'vip') AS vip_sales,
    SUM(ol.quantity * ol.unit_price) AS total_sales
FROM categories c
JOIN products p ON c.id = p.category_id
JOIN order_lines ol ON p.id = ol.product_id
JOIN orders o ON ol.order_id = o.id
JOIN customers cu ON o.customer_id = cu.id
GROUP BY c.name
ORDER BY total_sales DESC;</code></pre>

                <h3>Method 3: crosstab() Function (tablefunc extension)</h3>
                <pre><code class="language-sql">-- Enable the extension first
CREATE EXTENSION IF NOT EXISTS tablefunc;

-- Dynamic pivot with crosstab
SELECT * FROM crosstab(
    $$
    SELECT
        customer_type,
        TO_CHAR(order_date, 'Mon') AS month,
        SUM(total_amount)::NUMERIC
    FROM orders o
    JOIN customers c ON o.customer_id = c.id
    WHERE order_date >= '2024-01-01' AND order_date < '2024-04-01'
    GROUP BY customer_type, TO_CHAR(order_date, 'Mon'), EXTRACT(MONTH FROM order_date)
    ORDER BY customer_type, EXTRACT(MONTH FROM order_date)
    $$,
    $$ VALUES ('Jan'), ('Feb'), ('Mar') $$
) AS ct(customer_type VARCHAR, jan NUMERIC, feb NUMERIC, mar NUMERIC);</code></pre>

                <h3>Unpivoting: Columns to Rows</h3>
                <p>The reverse operation - converting columns back to rows:</p>

                <pre><code class="language-sql">-- Sample pivoted data
CREATE TABLE quarterly_sales (
    product VARCHAR(50),
    q1_sales DECIMAL(10,2),
    q2_sales DECIMAL(10,2),
    q3_sales DECIMAL(10,2),
    q4_sales DECIMAL(10,2)
);

-- Unpivot using UNION ALL
SELECT product, 'Q1' AS quarter, q1_sales AS sales FROM quarterly_sales
UNION ALL
SELECT product, 'Q2', q2_sales FROM quarterly_sales
UNION ALL
SELECT product, 'Q3', q3_sales FROM quarterly_sales
UNION ALL
SELECT product, 'Q4', q4_sales FROM quarterly_sales
ORDER BY product, quarter;

-- Unpivot using LATERAL (more elegant)
SELECT
    qs.product,
    x.quarter,
    x.sales
FROM quarterly_sales qs
CROSS JOIN LATERAL (
    VALUES
        ('Q1', q1_sales),
        ('Q2', q2_sales),
        ('Q3', q3_sales),
        ('Q4', q4_sales)
) AS x(quarter, sales)
ORDER BY product, quarter;</code></pre>
            </section>

            <!-- Section 5: Deduplication -->
            <section>
                <h2 id="deduplication">5. Deduplication Patterns</h2>

                <div class="pattern-box">
                    <strong>ðŸ’¡ Key Concept: Deduplication</strong><br>
                    <p style="margin-bottom: 0;">Duplicate records are a common data quality issue. Use <code>GROUP BY + HAVING COUNT(*) > 1</code> to find duplicates, and <code>ROW_NUMBER() OVER (PARTITION BY ...)</code> to delete them. Critical rule: Always run a SELECT first to see what will be affected, and decide which record to keep (oldest, newest, most complete).</p>
                </div>

                <p>Finding and handling duplicate records is a common data quality task.</p>

                <h3>Finding Duplicates</h3>
                <pre><code class="language-sql">-- Find duplicate emails in customers
SELECT
    email,
    COUNT(*) AS duplicate_count,
    ARRAY_AGG(id ORDER BY created_at) AS customer_ids,
    MIN(created_at) AS first_created,
    MAX(created_at) AS last_created
FROM customers
WHERE email IS NOT NULL
GROUP BY email
HAVING COUNT(*) > 1
ORDER BY duplicate_count DESC;</code></pre>

                <h3>Keeping Only One Record per Duplicate Group</h3>
                <pre><code class="language-sql">-- Method 1: Using ROW_NUMBER to identify duplicates to delete
WITH duplicates AS (
    SELECT
        id,
        email,
        ROW_NUMBER() OVER (
            PARTITION BY email
            ORDER BY created_at ASC  -- Keep oldest
        ) AS rn
    FROM customers
    WHERE email IS NOT NULL
)
SELECT * FROM duplicates WHERE rn > 1;  -- These are duplicates to remove

-- Method 2: Delete duplicates (keeping the oldest)
DELETE FROM customers
WHERE id IN (
    SELECT id FROM (
        SELECT
            id,
            ROW_NUMBER() OVER (
                PARTITION BY email
                ORDER BY created_at ASC
            ) AS rn
        FROM customers
        WHERE email IS NOT NULL
    ) sub
    WHERE rn > 1
);</code></pre>

                <h3>Using DISTINCT ON for Deduplication</h3>
                <pre><code class="language-sql">-- Create deduplicated view keeping most recent record per email
CREATE VIEW customers_deduped AS
SELECT DISTINCT ON (email)
    id,
    name,
    email,
    phone,
    created_at
FROM customers
WHERE email IS NOT NULL
ORDER BY email, created_at DESC;  -- Keep most recent</code></pre>

                <div class="tip-box">
                    <strong>Best Practice:</strong> Before deleting duplicates, always:
                    <ol>
                        <li>Run a SELECT first to see what will be affected</li>
                        <li>Create a backup or use a transaction with ROLLBACK ready</li>
                        <li>Define clear criteria for which record to keep (oldest, newest, most complete)</li>
                    </ol>
                </div>
            </section>

            <!-- Section 6: Date Range Operations -->
            <section>
                <h2 id="date-ranges">6. Date Range and Overlap Detection</h2>

                <div class="pattern-box">
                    <strong>ðŸ’¡ Key Concept: Date Range Overlap</strong><br>
                    <p style="margin-bottom: 0;">Date range overlap determines whether two periods share common time. Critical in booking systems, campaign management, project scheduling. Overlap formula: <code>A_start <= B_end AND A_end >= B_start</code>. PostgreSQL's <code>DATERANGE</code> type and operators like <code>&&</code> (overlaps) and <code>@></code> (contains) simplify these operations.</p>
                </div>

                <p>Working with date ranges and detecting overlaps is common in scheduling,
                   booking systems, and validity periods.</p>

                <h3>Detecting Overlapping Ranges</h3>
                <pre><code class="language-sql">-- Sample: room bookings
CREATE TABLE room_bookings (
    id SERIAL PRIMARY KEY,
    room_id INTEGER,
    start_date DATE,
    end_date DATE,
    guest_name VARCHAR(100)
);

-- Find overlapping bookings for the same room
SELECT
    a.id AS booking1,
    b.id AS booking2,
    a.room_id,
    a.start_date AS start1, a.end_date AS end1,
    b.start_date AS start2, b.end_date AS end2,
    a.guest_name AS guest1,
    b.guest_name AS guest2
FROM room_bookings a
JOIN room_bookings b ON a.room_id = b.room_id
    AND a.id < b.id  -- Avoid self-join and duplicates
WHERE a.start_date <= b.end_date
  AND a.end_date >= b.start_date;  -- Overlap condition</code></pre>

                <div class="pattern-box">
                    <strong>Overlap Logic:</strong> Two ranges [A_start, A_end] and [B_start, B_end] overlap if:
                    <code>A_start <= B_end AND A_end >= B_start</code>
                    <br><br>
                    Non-overlap: <code>A_end < B_start OR A_start > B_end</code>
                </div>

                <h3>Using PostgreSQL Range Types</h3>

                <div class="warning-box">
                    <strong>ðŸ“š Term: PostgreSQL Range Types</strong><br>
                    <p style="margin-bottom: 0;">PostgreSQL provides built-in types for range data: <code>int4range</code>, <code>int8range</code>, <code>numrange</code>, <code>tsrange</code> (timestamp), <code>tstzrange</code> (timestamp with timezone), <code>daterange</code>. Range operators: <code>&&</code> (overlaps?), <code>@></code> (contains?), <code>&lt;@</code> (contained by?), <code>*</code> (intersection), <code>+</code> (union). These operators dramatically simplify overlap queries.</p>
                </div>

                <p>PostgreSQL has built-in range types for more elegant range operations:</p>

                <pre><code class="language-sql">-- Using daterange type
CREATE TABLE promotions (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    valid_period DATERANGE,
    discount_percent INTEGER
);

-- Insert with range literals
INSERT INTO promotions (name, valid_period, discount_percent) VALUES
    ('Summer Sale', '[2024-06-01, 2024-08-31]', 20),
    ('Back to School', '[2024-08-15, 2024-09-15]', 15),
    ('Holiday Special', '[2024-12-01, 2024-12-31]', 25);

-- Find overlapping promotions using && operator
SELECT
    a.name AS promo1,
    b.name AS promo2,
    a.valid_period * b.valid_period AS overlap_period  -- Intersection
FROM promotions a
JOIN promotions b ON a.id < b.id
WHERE a.valid_period && b.valid_period;  -- Overlaps operator

-- Check if a date is within a range
SELECT name, discount_percent
FROM promotions
WHERE valid_period @> DATE '2024-08-20';  -- Contains operator

-- Find adjacent or overlapping ranges
SELECT name, valid_period
FROM promotions
WHERE valid_period -|- '[2024-09-01, 2024-09-30]'::daterange  -- Adjacent to
   OR valid_period && '[2024-09-01, 2024-09-30]'::daterange;  -- Overlaps</code></pre>

                <h3>Merging Overlapping Ranges</h3>
                <pre><code class="language-sql">-- Merge overlapping date ranges into continuous periods
WITH RECURSIVE date_ranges AS (
    -- Sample data
    SELECT 1 AS id, DATE '2024-01-01' AS start_date, DATE '2024-01-10' AS end_date
    UNION ALL SELECT 2, '2024-01-08', '2024-01-15'
    UNION ALL SELECT 3, '2024-01-20', '2024-01-25'
    UNION ALL SELECT 4, '2024-01-14', '2024-01-22'
),
ordered_ranges AS (
    SELECT *,
           ROW_NUMBER() OVER (ORDER BY start_date) AS rn
    FROM date_ranges
),
merged AS (
    SELECT start_date, end_date, rn
    FROM ordered_ranges WHERE rn = 1

    UNION ALL

    SELECT
        CASE
            WHEN o.start_date <= m.end_date + 1 THEN m.start_date
            ELSE o.start_date
        END,
        GREATEST(m.end_date, o.end_date),
        o.rn
    FROM merged m
    JOIN ordered_ranges o ON o.rn = m.rn + 1
)
SELECT DISTINCT ON (end_date)
    start_date, end_date
FROM merged
ORDER BY end_date, start_date;</code></pre>
            </section>

            <!-- Summary -->
            <section>
                <h2 id="summary">Summary</h2>
                <table class="table table-bordered">
                    <thead>
                        <tr>
                            <th>Pattern</th>
                            <th>Key Technique</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Recursive CTEs</td>
                            <td>WITH RECURSIVE + UNION ALL</td>
                            <td>Hierarchies, trees, sequences</td>
                        </tr>
                        <tr>
                            <td>Top-N per Group</td>
                            <td>ROW_NUMBER() + PARTITION BY</td>
                            <td>Best/worst per category</td>
                        </tr>
                        <tr>
                            <td>Gaps and Islands</td>
                            <td>value - ROW_NUMBER()</td>
                            <td>Finding sequences, missing data</td>
                        </tr>
                        <tr>
                            <td>Pivoting</td>
                            <td>CASE/FILTER + GROUP BY</td>
                            <td>Cross-tabulation reports</td>
                        </tr>
                        <tr>
                            <td>Deduplication</td>
                            <td>ROW_NUMBER() or DISTINCT ON</td>
                            <td>Data cleaning</td>
                        </tr>
                        <tr>
                            <td>Date Ranges</td>
                            <td>Range operators (&&, @>)</td>
                            <td>Scheduling, booking systems</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>Next:</strong> <a href="03_practical_sql_problem_solving_examples.html">Practice these patterns with hands-on exercises</a></p>
            </section>
        </div>
    </div>
</body>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous"></script>
<script src="../static/script.js"></script>

</html>
