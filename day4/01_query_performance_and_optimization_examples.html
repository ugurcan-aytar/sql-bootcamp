<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="../style_bootstrap.html">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/code.css">
    <link href="https://cdn.prod.website-files.com/5efdb54f07a6812bcd95cc65/6773d0fc3013e060f08d7145_favicon.jpg"
        rel="shortcut icon" type="image/x-icon">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Day 4: Query Performance and Optimization - Practical Examples</title>
    <style>
        code {
            white-space: pre-wrap;
        }

        span.smallcaps {
            font-variant: small-caps;
        }

        span.underline {
            text-decoration: underline;
        }

        div.column {
            display: inline-block;
            vertical-align: top;
            width: 50%;
        }

        div.hanging-indent {
            margin-left: 1.5em;
            text-indent: -1.5em;
        }

        ul.task-list {
            list-style: none;
        }

        .exercise-box {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .exercise-box h4 {
            color: #495057;
            margin-bottom: 15px;
        }

        .solution-content {
            background-color: #e8f5e9;
            border: 1px solid #a5d6a7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .solution-content.show {
            display: block;
        }

        .solution-toggle {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .solution-toggle:hover {
            background-color: #218838;
        }

        .hint-box {
            background-color: #fff3cd;
            border: 1px solid #ffecb5;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .hint-box strong {
            color: #664d03;
        }

        .warning-box {
            background-color: #f8d7da;
            border: 1px solid #f5c2c7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .warning-box strong {
            color: #842029;
        }

        .concept-box {
            background-color: #d1e7dd;
            border: 1px solid #badbcc;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .concept-box strong {
            color: #0f5132;
        }

        .dataset-table {
            font-size: 0.9em;
            margin: 15px 0;
        }

        .dataset-table th {
            background-color: #e9ecef;
        }

        .badge-operation {
            font-size: 0.75em;
            padding: 4px 8px;
            border-radius: 4px;
            margin-right: 5px;
        }

        .badge-scan {
            background-color: #dc3545;
            color: white;
        }

        .badge-index {
            background-color: #198754;
            color: white;
        }

        .badge-join {
            background-color: #0d6efd;
            color: white;
        }

        .badge-sort {
            background-color: #ffc107;
            color: black;
        }

        .badge-aggregate {
            background-color: #6f42c1;
            color: white;
        }

        .plan-output {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
        }

        .plan-good {
            border-left: 4px solid #198754;
        }

        .plan-bad {
            border-left: 4px solid #dc3545;
        }

        .comparison-table {
            width: 100%;
            margin: 15px 0;
        }

        .comparison-table td {
            vertical-align: top;
            padding: 10px;
        }

        .comparison-table .slow {
            background-color: #f8d7da;
        }

        .comparison-table .fast {
            background-color: #d1e7dd;
        }
        .language-switcher {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .language-switcher a {
            text-decoration: none;
            padding: 5px 10px;
            margin: 0 2px;
            border-radius: 3px;
            color: #333;
        }
        .language-switcher a.active {
            background: #0d6efd;
            color: #fff;
        }
        .language-switcher a:hover:not(.active) {
            background: #e9ecef;
        }
    </style>
</head>

<body>
    <a href="../index_en.html" class="back-button">← Back to Index</a>
    <div class="language-switcher">
        <a href="01_query_performance_and_optimization_examples.html" class="active">EN</a>
        <a href="01_query_performance_and_optimization_examples_tr.html">TR</a>
    </div>
    <div class="copy-notification" id="copyNotification">Copied!</div>

    <div id="europeanunion-turkey">
        <img src="../static/eu.png" alt="">
    </div>
    <div id="sanayiteknolojibakan">
        <img src="../static/sanayitek.png" alt="">
    </div>
    <div id="rekabet">
        <img src="../static/rekabet.png" alt="">
    </div>
    <div id="tisk">
        <img src="../static/tisk.png" alt="">
    </div>
    <div id="undp">
        <img src="../static/undp.png" alt="">
    </div>
    <div class="content-container">
        <div class="container">
            <section>
                <h1>Query Performance and Optimization - Practical Examples</h1>
                <p class="lead">Master execution plans, indexing strategies, and query optimization techniques through
                    hands-on exercises.</p>

                <div class="hint-box">
                    <strong>Learning Objectives:</strong>
                    <ul class="mb-0">
                        <li>Read and interpret EXPLAIN output</li>
                        <li>Identify performance bottlenecks in execution plans</li>
                        <li>Design effective indexes for different query patterns</li>
                        <li>Rewrite slow queries for better performance</li>
                    </ul>
                </div>
            </section>

            <!-- Sample Dataset -->
            <section>
                <h3>Sample Database Schema</h3>
                <p>We'll use an e-commerce database with the following tables:</p>

                <div class="row">
                    <div class="col-md-6">
                        <h5>customers (sales schema)</h5>
                        <table class="table table-bordered dataset-table">
                            <thead>
                                <tr>
                                    <th>Column</th>
                                    <th>Type</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>id</td>
                                    <td><span class="badge bg-primary">SERIAL PK</span></td>
                                    <td>Primary Key</td>
                                </tr>
                                <tr>
                                    <td>email</td>
                                    <td><span class="badge bg-secondary">VARCHAR(100)</span></td>
                                    <td>Unique</td>
                                </tr>
                                <tr>
                                    <td>first_name</td>
                                    <td><span class="badge bg-secondary">VARCHAR(50)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>last_name</td>
                                    <td><span class="badge bg-secondary">VARCHAR(50)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>country_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK to countries</td>
                                </tr>
                                <tr>
                                    <td>is_active</td>
                                    <td><span class="badge bg-info">BOOLEAN</span></td>
                                    <td>90% TRUE</td>
                                </tr>
                                <tr>
                                    <td>created_at</td>
                                    <td><span class="badge bg-warning text-dark">TIMESTAMP</span></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                        <p><strong>Large table for examples</strong></p>
                    </div>
                    <div class="col-md-6">
                        <h5>orders (sales schema)</h5>
                        <table class="table table-bordered dataset-table">
                            <thead>
                                <tr>
                                    <th>Column</th>
                                    <th>Type</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>id</td>
                                    <td><span class="badge bg-primary">SERIAL PK</span></td>
                                    <td>Primary Key</td>
                                </tr>
                                <tr>
                                    <td>customer_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK to customers.id</td>
                                </tr>
                                <tr>
                                    <td>order_date</td>
                                    <td><span class="badge bg-warning text-dark">DATE</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>status</td>
                                    <td><span class="badge bg-secondary">VARCHAR(20)</span></td>
                                    <td>draft, confirmed, processing, shipped, delivered, cancelled, returned</td>
                                </tr>
                                <tr>
                                    <td>total_amount</td>
                                    <td><span class="badge bg-info">DECIMAL(10,2)</span></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                        <p><strong>Large table for examples</strong></p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <h5>order_lines (sales schema)</h5>
                        <table class="table table-bordered dataset-table">
                            <thead>
                                <tr>
                                    <th>Column</th>
                                    <th>Type</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>id</td>
                                    <td><span class="badge bg-primary">SERIAL PK</span></td>
                                    <td>Primary Key</td>
                                </tr>
                                <tr>
                                    <td>order_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK to orders.id</td>
                                </tr>
                                <tr>
                                    <td>product_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK to products.id</td>
                                </tr>
                                <tr>
                                    <td>quantity</td>
                                    <td><span class="badge bg-info">INTEGER</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>unit_price</td>
                                    <td><span class="badge bg-info">DECIMAL(10,2)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>line_total</td>
                                    <td><span class="badge bg-info">DECIMAL(10,2)</span></td>
                                    <td>quantity * unit_price</td>
                                </tr>
                            </tbody>
                        </table>
                        <p><strong>Large table for examples</strong></p>
                    </div>
                    <div class="col-md-6">
                        <h5>products (sales schema)</h5>
                        <table class="table table-bordered dataset-table">
                            <thead>
                                <tr>
                                    <th>Column</th>
                                    <th>Type</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>id</td>
                                    <td><span class="badge bg-primary">SERIAL PK</span></td>
                                    <td>Primary Key</td>
                                </tr>
                                <tr>
                                    <td>name</td>
                                    <td><span class="badge bg-secondary">VARCHAR(200)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>category_id</td>
                                    <td><span class="badge bg-success">INTEGER FK</span></td>
                                    <td>FK to categories.id</td>
                                </tr>
                                <tr>
                                    <td>price</td>
                                    <td><span class="badge bg-info">DECIMAL(10,2)</span></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>is_active</td>
                                    <td><span class="badge bg-info">BOOLEAN</span></td>
                                    <td>95% TRUE</td>
                                </tr>
                            </tbody>
                        </table>
                        <p><strong>Smaller reference table</strong></p>
                    </div>
                </div>

                <div class="concept-box">
                    <strong>Initial Indexes (Primary Keys Only):</strong><br>
                    The database starts with only primary key indexes. Foreign key columns don't have indexes yet.
                </div>
            </section>

            <!-- Part 1: Reading Execution Plans -->
            <section>
                <h2>Part 1: Reading Execution Plans</h2>
                <p>Learn to interpret EXPLAIN output and identify performance issues.</p>

                <div class="exercise-box">
                    <h4>Exercise 1.1: Understanding Basic Plan Operations</h4>
                    <p>Given the following PostgreSQL EXPLAIN output, identify the operations and estimate
                        performance characteristics:</p>

                    <div class="plan-output plan-bad">
<pre>EXPLAIN SELECT * FROM sales.orders WHERE status = 'processing';

Seq Scan on orders  (cost=0.00..45123.00 rows=150000 width=52)
  Filter: ((status)::text = 'processing'::text)
</pre>
                    </div>

                    <p><strong>Questions:</strong></p>
                    <ol>
                        <li>What operation is being performed?</li>
                        <li>Why might this be inefficient for a table with 2 million rows?</li>
                        <li>What does the cost estimate (0.00..45123.00) represent?</li>
                    </ol>

                    <button class="solution-toggle" onclick="toggleSolution('sol1_1')">Show Solution</button>
                    <div id="sol1_1" class="solution-content">
                        <p><strong>Answers:</strong></p>
                        <ol>
                            <li><span class="badge badge-operation badge-scan">Seq Scan</span> - A <strong>Sequential
                                    Scan</strong> (full table scan) reads every row in the table.</li>
                            <li>The query only needs ~150,000 rows (7.5% of 2M), but it reads ALL 2 million rows. This
                                wastes I/O and CPU.</li>
                            <li>The cost has two numbers:
                                <ul>
                                    <li><strong>0.00</strong> = startup cost (work before returning first row)</li>
                                    <li><strong>45123.00</strong> = total cost in arbitrary units (higher = slower)</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>Optimization:</strong> Create an index on the <code>status</code> column:</p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_status <span class="kw">ON</span> orders (status);</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 1.2: Comparing Plan Operations</h4>
                    <p>Compare these two execution plans for the same query after adding an index:</p>

                    <div class="row">
                        <div class="col-md-6">
                            <h6>Before Index:</h6>
                            <div class="plan-output plan-bad">
<pre>Seq Scan on orders
  (cost=0.00..45123.00 rows=150000)
  Filter: status = 'processing'

Actual Time: 892.45ms
Rows Returned: 148,532</pre>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <h6>After Index:</h6>
                            <div class="plan-output plan-good">
<pre>Bitmap Heap Scan on orders
  (cost=1523.00..28456.00 rows=150000)
  Recheck Cond: status = 'processing'
  -> Bitmap Index Scan on idx_orders_status
       (cost=0.00..1485.00 rows=150000)

Actual Time: 124.32ms
Rows Returned: 148,532</pre>
                            </div>
                        </div>
                    </div>

                    <p><strong>Questions:</strong></p>
                    <ol>
                        <li>What new operations appear in the optimized plan?</li>
                        <li>Calculate the performance improvement.</li>
                        <li>Why does PostgreSQL use a Bitmap scan instead of a simple Index Scan?</li>
                    </ol>

                    <button class="solution-toggle" onclick="toggleSolution('sol1_2')">Show Solution</button>
                    <div id="sol1_2" class="solution-content">
                        <p><strong>Answers:</strong></p>
                        <ol>
                            <li>
                                <span class="badge badge-operation badge-index">Bitmap Index Scan</span> - Scans the
                                index to build a bitmap of matching rows<br>
                                <span class="badge badge-operation badge-scan">Bitmap Heap Scan</span> - Uses the
                                bitmap to fetch actual rows from the table
                            </li>
                            <li>Performance improvement: <strong>892.45ms → 124.32ms = 7.2x faster</strong><br>
                                Cost reduction: 45123 → 28456 = 37% lower estimated cost</li>
                            <li>PostgreSQL uses Bitmap Scan when retrieving many rows (7.5% of table). It's more
                                efficient than Index Scan for large result sets because:
                                <ul>
                                    <li>It reduces random I/O by sorting row locations</li>
                                    <li>It can combine multiple index conditions efficiently</li>
                                    <li>A simple Index Scan would cause too many random disk seeks</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 1.3: Identifying Join Operations</h4>
                    <p>Analyze this execution plan for a join query:</p>

                    <pre><code class="sourceCode sql"><span class="kw">SELECT</span> c.email, o.order_date, o.total_amount
<span class="kw">FROM</span> customers c
<span class="kw">JOIN</span> orders o <span class="kw">ON</span> c.customer_id = o.customer_id
<span class="kw">WHERE</span> c.country = <span class="st">'Germany'</span>
  <span class="kw">AND</span> o.order_date >= <span class="st">'2024-01-01'</span>;</code></pre>

                    <div class="plan-output plan-bad">
<pre>Hash Join  (cost=15234.00..98765.00 rows=25000 width=48)
  Hash Cond: (o.customer_id = c.customer_id)
  ->  Seq Scan on orders o  (cost=0.00..45123.00 rows=500000 width=20)
        Filter: (order_date >= '2024-01-01')
  ->  Hash  (cost=12456.00..12456.00 rows=12500 width=36)
        ->  Seq Scan on customers c  (cost=0.00..12456.00 rows=12500 width=36)
              Filter: (country = 'Germany')
</pre>
                    </div>

                    <p><strong>Questions:</strong></p>
                    <ol>
                        <li>What join algorithm is being used?</li>
                        <li>Identify all sequential scans - which ones could benefit from indexes?</li>
                        <li>What indexes would you create to optimize this query?</li>
                    </ol>

                    <button class="solution-toggle" onclick="toggleSolution('sol1_3')">Show Solution</button>
                    <div id="sol1_3" class="solution-content">
                        <p><strong>Answers:</strong></p>
                        <ol>
                            <li><span class="badge badge-operation badge-join">Hash Join</span> - Builds a hash table
                                from the smaller result (customers from Germany) and probes it with the larger result
                                (orders).</li>
                            <li>Two sequential scans identified:
                                <ul>
                                    <li><code>customers</code> filtered by <code>country = 'Germany'</code> - Would
                                        benefit from index</li>
                                    <li><code>orders</code> filtered by <code>order_date >= '2024-01-01'</code> - Would
                                        benefit from index</li>
                                </ul>
                            </li>
                            <li>Recommended indexes:
                                <pre><code class="sourceCode sql"><span class="co">-- Index for customer country filter</span>
<span class="kw">CREATE INDEX</span> idx_customers_country <span class="kw">ON</span> customers (country);

<span class="co">-- Index for order date range filter</span>
<span class="kw">CREATE INDEX</span> idx_orders_date <span class="kw">ON</span> orders (order_date);

<span class="co">-- Index for join condition (critical!)</span>
<span class="kw">CREATE INDEX</span> idx_orders_customer_id <span class="kw">ON</span> orders (customer_id);</code></pre>
                            </li>
                        </ol>
                        <p>After indexes, the plan might use Nested Loop with Index Scans for much better performance.
                        </p>
                    </div>
                </div>
            </section>

            <!-- Part 2: Index Design -->
            <section>
                <h2>Part 2: Index Design Exercises</h2>
                <p>Practice designing optimal indexes for different query patterns.</p>

                <div class="exercise-box">
                    <h4>Exercise 2.1: Single-Column vs Composite Index</h4>
                    <p>You have these two frequently executed queries:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Query A: Find orders by status</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> orders <span class="kw">WHERE</span> status = <span class="st">'shipped'</span>;

<span class="co">-- Query B: Find shipped orders in a date range</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> orders
<span class="kw">WHERE</span> status = <span class="st">'shipped'</span>
  <span class="kw">AND</span> order_date <span class="kw">BETWEEN</span> <span class="st">'2024-01-01'</span> <span class="kw">AND</span> <span class="st">'2024-03-31'</span>;</code></pre>

                    <p><strong>Task:</strong> Design the optimal index(es) to support both queries efficiently.</p>

                    <div class="hint-box">
                        <strong>Hint:</strong> Consider the column order in composite indexes. Equality predicates
                        should come before range predicates.
                    </div>

                    <button class="solution-toggle" onclick="toggleSolution('sol2_1')">Show Solution</button>
                    <div id="sol2_1" class="solution-content">
                        <p><strong>Optimal Solution:</strong> Create ONE composite index:</p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_status_date <span class="kw">ON</span> orders (status, order_date);</code></pre>

                        <p><strong>Why this works:</strong></p>
                        <ul>
                            <li><strong>Query A</strong>: Uses the leftmost column (status) - index is used</li>
                            <li><strong>Query B</strong>: Uses both columns - status equality first, then date range
                            </li>
                        </ul>

                        <p><strong>Why NOT separate indexes?</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Less optimal approach:</span>
<span class="kw">CREATE INDEX</span> idx_orders_status <span class="kw">ON</span> orders (status);
<span class="kw">CREATE INDEX</span> idx_orders_date <span class="kw">ON</span> orders (order_date);</code></pre>
                        <ul>
                            <li>Query B would need to combine two indexes (Bitmap AND) or pick only one</li>
                            <li>More indexes = more storage and slower writes</li>
                        </ul>

                        <div class="warning-box">
                            <strong>Column Order Matters!</strong><br>
                            An index on <code>(order_date, status)</code> would NOT efficiently support Query A
                            because the leftmost column is not used.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 2.2: Partial Index Design</h4>
                    <p>Your application frequently runs this query:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Find processing orders for follow-up</span>
<span class="kw">SELECT</span> id, customer_id, order_date, total_amount
<span class="kw">FROM</span> sales.orders
<span class="kw">WHERE</span> status = <span class="st">'processing'</span>
<span class="kw">ORDER BY</span> order_date;</code></pre>

                    <p>Data distribution: Only 2% of orders have status = 'processing' (orders awaiting fulfillment).</p>

                    <p><strong>Task:</strong> Design the most efficient index for this query.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol2_2')">Show Solution</button>
                    <div id="sol2_2" class="solution-content">
                        <p><strong>Optimal Solution:</strong> Create a partial index:</p>
                        <pre><code class="sourceCode sql"><span class="co">-- PostgreSQL partial index</span>
<span class="kw">CREATE INDEX</span> idx_orders_processing_date
<span class="kw">ON</span> sales.orders (order_date)
<span class="kw">WHERE</span> status = <span class="st">'processing'</span>;</code></pre>

                        <p><strong>Benefits:</strong></p>
                        <table class="table table-bordered">
                            <tr>
                                <th>Metric</th>
                                <th>Full Index</th>
                                <th>Partial Index</th>
                            </tr>
                            <tr>
                                <td>Rows indexed</td>
                                <td>All orders</td>
                                <td>Only processing (small %)</td>
                            </tr>
                            <tr>
                                <td>Index size</td>
                                <td>Large</td>
                                <td>Much smaller</td>
                            </tr>
                            <tr>
                                <td>Insert overhead</td>
                                <td>Every insert</td>
                                <td>Only processing orders</td>
                            </tr>
                        </table>

                        <p><strong>SQL Server equivalent (Filtered Index):</strong></p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_processing_date
<span class="kw">ON</span> orders (order_date)
<span class="kw">WHERE</span> status = <span class="st">'processing'</span>;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 2.3: Covering Index Design</h4>
                    <p>This query runs thousands of times per minute in your dashboard:</p>

                    <pre><code class="sourceCode sql"><span class="kw">SELECT</span> order_date, total_amount
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">10</span>;</code></pre>

                    <p><strong>Task:</strong> Design an index that allows this query to be answered entirely from the
                        index (Index-Only Scan).</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol2_3')">Show Solution</button>
                    <div id="sol2_3" class="solution-content">
                        <p><strong>Solution - Covering Index:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- PostgreSQL (include non-key columns)</span>
<span class="kw">CREATE INDEX</span> idx_orders_customer_covering
<span class="kw">ON</span> orders (customer_id, order_date <span class="kw">DESC</span>)
<span class="kw">INCLUDE</span> (total_amount);

<span class="co">-- Alternative: All columns in index key</span>
<span class="kw">CREATE INDEX</span> idx_orders_customer_covering_alt
<span class="kw">ON</span> orders (customer_id, order_date <span class="kw">DESC</span>, total_amount);</code></pre>

                        <p><strong>Why this works:</strong></p>
                        <ul>
                            <li><code>customer_id</code> - First key for equality filter</li>
                            <li><code>order_date DESC</code> - Second key for sorting (already in order!)</li>
                            <li><code>total_amount</code> - Included so no table access needed</li>
                        </ul>

                        <div class="plan-output plan-good">
<pre>Index Only Scan using idx_orders_customer_covering
  (cost=0.43..12.56 rows=10 width=16)
  Index Cond: (customer_id = 12345)
  Heap Fetches: 0  <-- No table access!</pre>
                        </div>

                        <div class="concept-box">
                            <strong>INCLUDE vs Key Columns:</strong><br>
                            Use <code>INCLUDE</code> for columns only needed in SELECT (not used in WHERE/ORDER BY).
                            This keeps the index tree smaller and faster to traverse.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 2.4: Expression Index</h4>
                    <p>Users search for customers by email, but the search is case-insensitive:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Current slow query</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers
<span class="kw">WHERE</span> <span class="fu">LOWER</span>(email) = <span class="st">'john.doe@example.com'</span>;</code></pre>

                    <p>A regular index on <code>email</code> won't help because of the <code>LOWER()</code>
                        function.</p>

                    <p><strong>Task:</strong> Create an index that supports this case-insensitive search.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol2_4')">Show Solution</button>
                    <div id="sol2_4" class="solution-content">
                        <p><strong>Solution - Expression Index:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- PostgreSQL expression index</span>
<span class="kw">CREATE INDEX</span> idx_customers_email_lower
<span class="kw">ON</span> customers (<span class="fu">LOWER</span>(email));

<span class="co">-- Query must use the same expression:</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers
<span class="kw">WHERE</span> <span class="fu">LOWER</span>(email) = <span class="fu">LOWER</span>(<span class="st">'John.Doe@Example.com'</span>);</code></pre>

                        <p><strong>Alternative approaches:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- PostgreSQL: Use citext extension for case-insensitive text</span>
<span class="kw">CREATE EXTENSION IF NOT EXISTS</span> citext;
<span class="kw">ALTER TABLE</span> customers <span class="kw">ALTER COLUMN</span> email <span class="kw">TYPE</span> citext;
<span class="co">-- Now regular index works: WHERE email = 'John.Doe@Example.com'</span>

<span class="co">-- SQL Server: Use case-insensitive collation</span>
<span class="kw">CREATE INDEX</span> idx_customers_email <span class="kw">ON</span> customers (email);
<span class="co">-- Default collation is usually case-insensitive</span></code></pre>

                        <div class="warning-box">
                            <strong>Important:</strong> The query must use the EXACT same expression as the index.
                            <code>WHERE UPPER(email) = ...</code> would NOT use this index!
                        </div>
                    </div>
                </div>
            </section>

            <!-- Part 3: Query Rewriting -->
            <section>
                <h2>Part 3: Query Rewriting for Performance</h2>
                <p>Transform slow queries into optimized versions.</p>

                <div class="exercise-box">
                    <h4>Exercise 3.1: Avoiding Functions on Indexed Columns</h4>
                    <p>This query runs slowly despite having an index on <code>order_date</code>:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Slow query (cannot use index)</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> orders
<span class="kw">WHERE</span> <span class="fu">YEAR</span>(order_date) = <span class="dv">2024</span>;</code></pre>

                    <p><strong>Task:</strong> Rewrite the query to use the index on <code>order_date</code>.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol3_1')">Show Solution</button>
                    <div id="sol3_1" class="solution-content">
                        <p><strong>Optimized Query:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Use range condition instead of function</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> orders
<span class="kw">WHERE</span> order_date >= <span class="st">'2024-01-01'</span>
  <span class="kw">AND</span> order_date < <span class="st">'2025-01-01'</span>;</code></pre>

                        <table class="comparison-table">
                            <tr>
                                <td class="slow" style="width: 50%;">
                                    <strong>Before (Slow):</strong>
                                    <div class="plan-output plan-bad">
<pre>Seq Scan on orders
cost=0.00..55123.00
Filter: YEAR(order_date) = 2024</pre>
                                    </div>
                                </td>
                                <td class="fast" style="width: 50%;">
                                    <strong>After (Fast):</strong>
                                    <div class="plan-output plan-good">
<pre>Index Scan using idx_orders_date
cost=0.43..8456.00
Index Cond: (order_date >= ... AND ...)</pre>
                                    </div>
                                </td>
                            </tr>
                        </table>

                        <p><strong>More examples:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Bad: Function on column</span>
<span class="kw">WHERE</span> <span class="fu">DATE</span>(created_at) = <span class="st">'2024-06-15'</span>
<span class="co">-- Good: Range condition</span>
<span class="kw">WHERE</span> created_at >= <span class="st">'2024-06-15'</span> <span class="kw">AND</span> created_at < <span class="st">'2024-06-16'</span>

<span class="co">-- Bad: Calculation on column</span>
<span class="kw">WHERE</span> total_amount * <span class="fl">1.1</span> > <span class="dv">100</span>
<span class="co">-- Good: Move calculation to constant</span>
<span class="kw">WHERE</span> total_amount > <span class="dv">100</span> / <span class="fl">1.1</span>

<span class="co">-- Bad: String function</span>
<span class="kw">WHERE</span> <span class="fu">SUBSTRING</span>(code, <span class="dv">1</span>, <span class="dv">3</span>) = <span class="st">'ABC'</span>
<span class="co">-- Good: Use LIKE with prefix</span>
<span class="kw">WHERE</span> code <span class="kw">LIKE</span> <span class="st">'ABC%'</span></code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 3.2: Replacing Correlated Subquery with JOIN</h4>
                    <p>This query finds customers with their most recent order, but runs very slowly:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Slow: Correlated subquery (runs once per customer)</span>
<span class="kw">SELECT</span>
    c.customer_id,
    c.email,
    (
        <span class="kw">SELECT</span> <span class="fu">MAX</span>(o.order_date)
        <span class="kw">FROM</span> orders o
        <span class="kw">WHERE</span> o.customer_id = c.customer_id
    ) <span class="kw">AS</span> last_order_date
<span class="kw">FROM</span> customers c
<span class="kw">WHERE</span> c.is_active = <span class="kw">TRUE</span>;</code></pre>

                    <p><strong>Task:</strong> Rewrite using a JOIN for better performance.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol3_2')">Show Solution</button>
                    <div id="sol3_2" class="solution-content">
                        <p><strong>Optimized Query using JOIN:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Fast: Single aggregation with JOIN</span>
<span class="kw">SELECT</span>
    c.customer_id,
    c.email,
    <span class="fu">MAX</span>(o.order_date) <span class="kw">AS</span> last_order_date
<span class="kw">FROM</span> customers c
<span class="kw">LEFT JOIN</span> orders o <span class="kw">ON</span> c.customer_id = o.customer_id
<span class="kw">WHERE</span> c.is_active = <span class="kw">TRUE</span>
<span class="kw">GROUP BY</span> c.customer_id, c.email;</code></pre>

                        <p><strong>Alternative using Window Function (get full order details):</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Get the actual most recent order, not just the date</span>
<span class="kw">WITH</span> ranked_orders <span class="kw">AS</span> (
    <span class="kw">SELECT</span>
        o.*,
        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (
            <span class="kw">PARTITION BY</span> o.customer_id
            <span class="kw">ORDER BY</span> o.order_date <span class="kw">DESC</span>
        ) <span class="kw">AS</span> rn
    <span class="kw">FROM</span> orders o
)
<span class="kw">SELECT</span>
    c.customer_id,
    c.email,
    ro.order_date <span class="kw">AS</span> last_order_date,
    ro.total_amount <span class="kw">AS</span> last_order_amount
<span class="kw">FROM</span> customers c
<span class="kw">LEFT JOIN</span> ranked_orders ro
    <span class="kw">ON</span> c.customer_id = ro.customer_id <span class="kw">AND</span> ro.rn = <span class="dv">1</span>
<span class="kw">WHERE</span> c.is_active = <span class="kw">TRUE</span>;</code></pre>

                        <div class="concept-box">
                            <strong>Performance Comparison:</strong><br>
                            <ul class="mb-0">
                                <li>Correlated subquery: O(customers × orders) - executes subquery for EACH customer
                                </li>
                                <li>JOIN approach: O(customers + orders) - single pass through each table</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 3.3: EXISTS vs IN vs JOIN</h4>
                    <p>Find all customers who have placed at least one order. Compare three approaches:</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Approach 1: IN subquery</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers
<span class="kw">WHERE</span> customer_id <span class="kw">IN</span> (<span class="kw">SELECT</span> customer_id <span class="kw">FROM</span> orders);

<span class="co">-- Approach 2: EXISTS subquery</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers c
<span class="kw">WHERE</span> <span class="kw">EXISTS</span> (<span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">FROM</span> orders o <span class="kw">WHERE</span> o.customer_id = c.customer_id);

<span class="co">-- Approach 3: JOIN with DISTINCT</span>
<span class="kw">SELECT DISTINCT</span> c.* <span class="kw">FROM</span> customers c
<span class="kw">JOIN</span> orders o <span class="kw">ON</span> c.customer_id = o.customer_id;</code></pre>

                    <p><strong>Task:</strong> Analyze which approach is best and when.</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol3_3')">Show Solution</button>
                    <div id="sol3_3" class="solution-content">
                        <p><strong>Analysis:</strong></p>

                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Approach</th>
                                    <th>Best When</th>
                                    <th>Performance</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>EXISTS</code></td>
                                    <td>Large orders table, just checking existence</td>
                                    <td>Stops at first match (early termination)</td>
                                </tr>
                                <tr>
                                    <td><code>IN</code></td>
                                    <td>Small subquery result set</td>
                                    <td>Must build complete list first</td>
                                </tr>
                                <tr>
                                    <td><code>JOIN + DISTINCT</code></td>
                                    <td>When you need columns from both tables</td>
                                    <td>Extra work for deduplication</td>
                                </tr>
                            </tbody>
                        </table>

                        <p><strong>Recommendation for this specific case:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- EXISTS is typically best for existence checks</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers c
<span class="kw">WHERE</span> <span class="kw">EXISTS</span> (
    <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">FROM</span> orders o
    <span class="kw">WHERE</span> o.customer_id = c.customer_id
);</code></pre>

                        <p><strong>Required index for all approaches:</strong></p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_customer_id <span class="kw">ON</span> orders (customer_id);</code></pre>

                        <div class="hint-box">
                            <strong>Modern Optimizers:</strong> Most modern databases (PostgreSQL 12+, SQL Server 2019+)
                            can often optimize IN and EXISTS to produce similar plans. Always verify with EXPLAIN.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 3.4: UNION ALL vs UNION</h4>
                    <p>You need to combine active and VIP customers (VIP is a separate flag):</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Current slow query</span>
<span class="kw">SELECT</span> customer_id, email, <span class="st">'active'</span> <span class="kw">AS</span> source
<span class="kw">FROM</span> customers <span class="kw">WHERE</span> is_active = <span class="kw">TRUE</span>
<span class="kw">UNION</span>
<span class="kw">SELECT</span> customer_id, email, <span class="st">'vip'</span> <span class="kw">AS</span> source
<span class="kw">FROM</span> customers <span class="kw">WHERE</span> is_vip = <span class="kw">TRUE</span>;</code></pre>

                    <p><strong>Task:</strong> Optimize this query knowing that the same customer can be both active
                        AND VIP (and you want to see both rows in that case).</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol3_4')">Show Solution</button>
                    <div id="sol3_4" class="solution-content">
                        <p><strong>Optimized Query:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Use UNION ALL since duplicates are intentional</span>
<span class="kw">SELECT</span> customer_id, email, <span class="st">'active'</span> <span class="kw">AS</span> source
<span class="kw">FROM</span> customers <span class="kw">WHERE</span> is_active = <span class="kw">TRUE</span>
<span class="kw">UNION ALL</span>
<span class="kw">SELECT</span> customer_id, email, <span class="st">'vip'</span> <span class="kw">AS</span> source
<span class="kw">FROM</span> customers <span class="kw">WHERE</span> is_vip = <span class="kw">TRUE</span>;</code></pre>

                        <table class="comparison-table">
                            <tr>
                                <td class="slow">
                                    <strong>UNION (Slow):</strong>
                                    <ul>
                                        <li>Combines results</li>
                                        <li>Sorts all rows</li>
                                        <li>Removes duplicates</li>
                                    </ul>
                                </td>
                                <td class="fast">
                                    <strong>UNION ALL (Fast):</strong>
                                    <ul>
                                        <li>Combines results</li>
                                        <li>Done!</li>
                                        <li>&nbsp;</li>
                                    </ul>
                                </td>
                            </tr>
                        </table>

                        <div class="warning-box">
                            <strong>When to use UNION (not ALL):</strong><br>
                            Only use UNION when you specifically need to remove duplicates and the queries might
                            return the same rows. If queries are mutually exclusive or you want all rows, use UNION
                            ALL.
                        </div>
                    </div>
                </div>
            </section>

            <!-- Part 4: Challenge Exercises -->
            <section>
                <h2>Part 4: Challenge Exercises (Step-by-Step)</h2>
                <p>Work through these real-world scenarios with guided questions. Take your time!</p>

                <div class="hint-box">
                    <strong>How to approach these challenges:</strong>
                    <ul class="mb-0">
                        <li>Read each step carefully before moving to the next</li>
                        <li>Try to answer each question before clicking "Show Answer"</li>
                        <li>Don't worry if you don't get everything right - learning is the goal!</li>
                    </ul>
                </div>

                <div class="exercise-box">
                    <h4>Challenge 4.1: Optimize a Reporting Query (Guided)</h4>
                    <p>A monthly sales report is running slow (45 seconds). Let's optimize it step by step!</p>

                    <pre><code class="sourceCode sql"><span class="co">-- The slow query we need to optimize</span>
<span class="kw">SELECT</span>
    c.name <span class="kw">AS</span> category,
    <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, o.order_date) <span class="kw">AS</span> month,
    <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> o.id) <span class="kw">AS</span> order_count,
    <span class="fu">SUM</span>(ol.line_total) <span class="kw">AS</span> revenue
<span class="kw">FROM</span> sales.orders o
<span class="kw">JOIN</span> sales.order_lines ol <span class="kw">ON</span> o.id = ol.order_id
<span class="kw">JOIN</span> sales.products p <span class="kw">ON</span> ol.product_id = p.id
<span class="kw">JOIN</span> sales.categories c <span class="kw">ON</span> p.category_id = c.id
<span class="kw">WHERE</span> o.order_date >= <span class="st">'2024-01-01'</span>
  <span class="kw">AND</span> o.status <span class="kw">IN</span> (<span class="st">'delivered'</span>, <span class="st">'shipped'</span>)
<span class="kw">GROUP BY</span> c.name, <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, o.order_date)
<span class="kw">ORDER BY</span> month, revenue <span class="kw">DESC</span>;</code></pre>

                    <h5>Step 1: Identify the Tables</h5>
                    <p><strong>Question:</strong> How many tables are joined in this query? List them.</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_1_step1')">Show Answer</button>
                    <div id="sol4_1_step1" class="solution-content">
                        <p><strong>4 tables are joined:</strong></p>
                        <ol>
                            <li><code>orders</code> (aliased as <code>o</code>)</li>
                            <li><code>order_lines</code> (aliased as <code>ol</code>)</li>
                            <li><code>products</code> (aliased as <code>p</code>)</li>
                            <li><code>categories</code> (aliased as <code>c</code>)</li>
                        </ol>
                    </div>

                    <h5>Step 2: Find the WHERE Filters</h5>
                    <p><strong>Question:</strong> What columns are being filtered in the WHERE clause?</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_1_step2')">Show Answer</button>
                    <div id="sol4_1_step2" class="solution-content">
                        <p><strong>Two columns are filtered:</strong></p>
                        <ol>
                            <li><code>o.order_date >= '2024-01-01'</code> - Date filter</li>
                            <li><code>o.status IN ('delivered', 'shipped')</code> - Status filter</li>
                        </ol>
                        <p>Both filters are on the <code>orders</code> table!</p>
                    </div>

                    <h5>Step 3: Design an Index for the Filters</h5>
                    <p><strong>Question:</strong> What index would help the WHERE clause? (Hint: put equality columns first, range columns second)</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_1_step3')">Show Answer</button>
                    <div id="sol4_1_step3" class="solution-content">
                        <p><strong>A composite index on orders:</strong></p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_date_status
<span class="kw">ON</span> sales.orders (order_date, status);</code></pre>
                        <p>Or even better, a partial index for just the statuses we need:</p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_date_status
<span class="kw">ON</span> sales.orders (order_date, status)
<span class="kw">WHERE</span> status <span class="kw">IN</span> (<span class="st">'delivered'</span>, <span class="st">'shipped'</span>);</code></pre>
                    </div>

                    <h5>Step 4: Design Indexes for the JOINs</h5>
                    <p><strong>Question:</strong> What columns are used in JOIN conditions? What indexes would help?</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_1_step4')">Show Answer</button>
                    <div id="sol4_1_step4" class="solution-content">
                        <p><strong>JOIN columns and indexes:</strong></p>
                        <table class="table table-bordered">
                            <tr><th>JOIN</th><th>Column</th><th>Index Needed</th></tr>
                            <tr><td>orders → order_lines</td><td>o.id = ol.order_id</td><td>Index on order_lines(order_id)</td></tr>
                            <tr><td>order_lines → products</td><td>ol.product_id = p.id</td><td>Primary key on products(id) already exists</td></tr>
                            <tr><td>products → categories</td><td>p.category_id = c.id</td><td>Primary key on categories(id) already exists</td></tr>
                        </table>
                        <pre><code class="sourceCode sql"><span class="co">-- Index for order_lines join</span>
<span class="kw">CREATE INDEX</span> idx_order_lines_order_id
<span class="kw">ON</span> sales.order_lines (order_id)
<span class="kw">INCLUDE</span> (product_id, line_total);</code></pre>
                    </div>

                    <h5>Step 5: Complete Solution</h5>
                    <p><strong>Now let's see the full optimization with all indexes and optional improvements:</strong></p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_1')">Show Complete Solution</button>
                    <div id="sol4_1" class="solution-content">
                        <p><strong>All recommended indexes:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Index for orders filtering</span>
<span class="kw">CREATE INDEX</span> idx_orders_date_status
<span class="kw">ON</span> sales.orders (order_date, status)
<span class="kw">WHERE</span> status <span class="kw">IN</span> (<span class="st">'delivered'</span>, <span class="st">'shipped'</span>);

<span class="co">-- Index for order_lines join</span>
<span class="kw">CREATE INDEX</span> idx_order_lines_order_id
<span class="kw">ON</span> sales.order_lines (order_id)
<span class="kw">INCLUDE</span> (product_id, line_total);

<span class="co">-- Index for products join</span>
<span class="kw">CREATE INDEX</span> idx_products_id_category
<span class="kw">ON</span> sales.products (id)
<span class="kw">INCLUDE</span> (category_id);</code></pre>

                        <p><strong>Bonus: For reports that run frequently, use a Materialized View:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Pre-compute the report data</span>
<span class="kw">CREATE MATERIALIZED VIEW</span> mv_monthly_sales <span class="kw">AS</span>
<span class="kw">SELECT</span>
    c.name <span class="kw">AS</span> category,
    <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, o.order_date) <span class="kw">AS</span> month,
    <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> o.id) <span class="kw">AS</span> order_count,
    <span class="fu">SUM</span>(ol.line_total) <span class="kw">AS</span> revenue
<span class="kw">FROM</span> sales.orders o
<span class="kw">JOIN</span> sales.order_lines ol <span class="kw">ON</span> o.id = ol.order_id
<span class="kw">JOIN</span> sales.products p <span class="kw">ON</span> ol.product_id = p.id
<span class="kw">JOIN</span> sales.categories c <span class="kw">ON</span> p.category_id = c.id
<span class="kw">WHERE</span> o.status <span class="kw">IN</span> (<span class="st">'delivered'</span>, <span class="st">'shipped'</span>)
<span class="kw">GROUP BY</span> c.name, <span class="fu">DATE_TRUNC</span>(<span class="st">'month'</span>, o.order_date);

<span class="co">-- Refresh when needed</span>
<span class="kw">REFRESH MATERIALIZED VIEW</span> mv_monthly_sales;</code></pre>

                        <div class="concept-box">
                            <strong>Expected Improvement:</strong> 45 seconds → 2-5 seconds with indexes, or sub-second with materialized view.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Challenge 4.2: Pagination Performance (Guided)</h4>
                    <p>Users complain that browsing to later pages is very slow. Let's understand why!</p>

                    <pre><code class="sourceCode sql"><span class="co">-- Page 1: Fast! (0-20)</span>
<span class="kw">SELECT</span> id, order_date, total_amount
<span class="kw">FROM</span> orders <span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">20</span> <span class="kw">OFFSET</span> <span class="dv">0</span>;

<span class="co">-- Page 1000: Very Slow! (19980-20000)</span>
<span class="kw">SELECT</span> id, order_date, total_amount
<span class="kw">FROM</span> orders <span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">20</span> <span class="kw">OFFSET</span> <span class="dv">19980</span>;</code></pre>

                    <h5>Step 1: Why is OFFSET Slow?</h5>
                    <p><strong>Question:</strong> If we ask for OFFSET 19980, how many rows does the database have to scan?</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_2_step1')">Show Answer</button>
                    <div id="sol4_2_step1" class="solution-content">
                        <p><strong>The database must scan 20,000 rows!</strong></p>
                        <ul>
                            <li>It finds all matching rows</li>
                            <li>Sorts them by order_date DESC</li>
                            <li>Skips the first 19,980 rows</li>
                            <li>Returns only 20 rows</li>
                        </ul>
                        <p>All that work just to throw away 19,980 rows!</p>
                    </div>

                    <h5>Step 2: A Better Approach</h5>
                    <p><strong>Question:</strong> Instead of using OFFSET, what if we remembered where we left off? If the last order on page 999 had <code>order_date='2024-03-15'</code>, how could we get page 1000?</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_2_step2')">Show Answer</button>
                    <div id="sol4_2_step2" class="solution-content">
                        <p><strong>Use the last row as a "cursor":</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- Instead of OFFSET, use WHERE to skip</span>
<span class="kw">SELECT</span> id, order_date, total_amount
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
  <span class="kw">AND</span> order_date < <span class="st">'2024-03-15'</span>  <span class="co">-- Continue from where we left off</span>
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">20</span>;</code></pre>
                        <p>This only scans ~20 rows regardless of which page we're on!</p>
                    </div>

                    <h5>Step 3: Complete Solution</h5>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_2')">Show Complete Solution</button>
                    <div id="sol4_2" class="solution-content">
                        <p><strong>Keyset (Cursor-Based) Pagination:</strong></p>
                        <pre><code class="sourceCode sql"><span class="co">-- First page (no cursor yet)</span>
<span class="kw">SELECT</span> id, order_date, total_amount
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>, id <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">20</span>;

<span class="co">-- Next page: use the last row's values</span>
<span class="co">-- If last row was: order_date='2024-03-15', id=98765</span>
<span class="kw">SELECT</span> id, order_date, total_amount
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> customer_id = <span class="dv">12345</span>
  <span class="kw">AND</span> (order_date, id) < (<span class="st">'2024-03-15'</span>, <span class="dv">98765</span>)
<span class="kw">ORDER BY</span> order_date <span class="kw">DESC</span>, id <span class="kw">DESC</span>
<span class="kw">LIMIT</span> <span class="dv">20</span>;</code></pre>

                        <p><strong>Supporting Index:</strong></p>
                        <pre><code class="sourceCode sql"><span class="kw">CREATE INDEX</span> idx_orders_customer_date_id
<span class="kw">ON</span> orders (customer_id, order_date <span class="kw">DESC</span>, id <span class="kw">DESC</span>);</code></pre>

                        <table class="table table-bordered">
                            <thead><tr><th>Method</th><th>Rows Scanned (Page 1000)</th><th>Speed</th></tr></thead>
                            <tbody>
                                <tr><td>OFFSET</td><td>~20,000</td><td>Slow (~500ms)</td></tr>
                                <tr><td>Keyset</td><td>~20</td><td>Fast (~1ms)</td></tr>
                            </tbody>
                        </table>

                        <div class="warning-box">
                            <strong>Note:</strong> Keyset pagination works great for "Load More" buttons and infinite scroll. It doesn't easily support "Jump to Page 500" - for that, OFFSET is still needed.
                        </div>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Challenge 4.3: Reading EXPLAIN Output (Guided)</h4>
                    <p>Let's learn to read this EXPLAIN output step by step. Don't panic - we'll break it down!</p>

                    <div class="plan-output plan-bad">
<pre>HashAggregate  (rows=1000) (actual rows=156)
  Group Key: c.email
  Filter: (sum(o.total_amount) > 1000)
  Rows Removed by Filter: 12456
  ->  Hash Join  (actual rows=456789)
        Hash Cond: (o.customer_id = c.customer_id)
        ->  Seq Scan on orders o  (actual rows=485632)
              Filter: (order_date >= '2024-01-01')
              Rows Removed by Filter: 1514368
        ->  Hash
              ->  Seq Scan on customers c  (actual rows=48765)
                    Filter: (lower(email) LIKE '%gmail.com')
                    Rows Removed by Filter: 451235

Execution Time: 8237.890 ms  <span class="co">-- That's 8+ seconds!</span></pre>
                    </div>

                    <h5>Step 1: Find the Seq Scans</h5>
                    <p><strong>Question:</strong> A "Seq Scan" (Sequential Scan) means reading the entire table. How many Seq Scans do you see? On which tables?</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_3_step1')">Show Answer</button>
                    <div id="sol4_3_step1" class="solution-content">
                        <p><strong>Two Seq Scans:</strong></p>
                        <ol>
                            <li><code>Seq Scan on orders</code> - Reading all order rows</li>
                            <li><code>Seq Scan on customers</code> - Reading all customer rows</li>
                        </ol>
                        <p>Seq Scans on large tables are usually a performance problem!</p>
                    </div>

                    <h5>Step 2: Look at the Filters</h5>
                    <p><strong>Question:</strong> For each Seq Scan, what filter is being applied? How many rows were removed?</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_3_step2')">Show Answer</button>
                    <div id="sol4_3_step2" class="solution-content">
                        <p><strong>Orders table:</strong></p>
                        <ul>
                            <li>Filter: <code>order_date >= '2024-01-01'</code></li>
                            <li>Rows removed: 1,514,368 (kept 485,632)</li>
                            <li><strong>Problem:</strong> No index on order_date!</li>
                        </ul>
                        <p><strong>Customers table:</strong></p>
                        <ul>
                            <li>Filter: <code>lower(email) LIKE '%gmail.com'</code></li>
                            <li>Rows removed: 451,235 (kept 48,765)</li>
                            <li><strong>Problem:</strong> Leading % and LOWER() prevent index use!</li>
                        </ul>
                    </div>

                    <h5>Step 3: Suggest Fixes</h5>
                    <p><strong>Question:</strong> What index would help the orders table?</p>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_3_step3')">Show Answer</button>
                    <div id="sol4_3_step3" class="solution-content">
                        <pre><code class="sourceCode sql"><span class="co">-- Index for the date filter</span>
<span class="kw">CREATE INDEX</span> idx_orders_date <span class="kw">ON</span> orders (order_date);</code></pre>
                    </div>

                    <h5>Step 4: Complete Analysis</h5>
                    <button class="solution-toggle" onclick="toggleSolution('sol4_3')">Show All Issues & Solutions</button>
                    <div id="sol4_3" class="solution-content">
                        <p><strong>All Issues Found:</strong></p>
                        <table class="table table-bordered">
                            <thead><tr><th>#</th><th>Issue</th><th>Solution</th></tr></thead>
                            <tbody>
                                <tr>
                                    <td>1</td>
                                    <td>Seq Scan on orders (1.5M rows scanned)</td>
                                    <td><code>CREATE INDEX idx_orders_date ON orders (order_date);</code></td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>Seq Scan on customers (500K rows scanned)</td>
                                    <td>The <code>LIKE '%gmail.com'</code> with leading % is hard to index. Consider using <code>pg_trgm</code> extension or storing email domain separately.</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>No index for JOIN (customer_id)</td>
                                    <td><code>CREATE INDEX idx_orders_customer ON orders (customer_id);</code></td>
                                </tr>
                                <tr>
                                    <td>4</td>
                                    <td>HAVING filters late (12,456 rows removed after aggregation)</td>
                                    <td>This is normal for HAVING - it runs after GROUP BY</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="concept-box">
                            <strong>Key Takeaway:</strong> When reading EXPLAIN output, look for:
                            <ul class="mb-0">
                                <li>"Seq Scan" on large tables = probably needs an index</li>
                                <li>"Rows Removed by Filter" = how selective is the filter?</li>
                                <li>Large differences between estimated and actual rows = stale statistics</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Key Takeaways -->
            <section>
                <h3>Key Takeaways</h3>
                <table class="table table-bordered">
                    <thead>
                        <tr>
                            <th>Topic</th>
                            <th>Key Points</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Execution Plans</strong></td>
                            <td>
                                <ul class="mb-0">
                                    <li>Use EXPLAIN ANALYZE to see actual vs estimated rows</li>
                                    <li>Watch for Seq Scans on large tables</li>
                                    <li>Large estimate/actual discrepancies indicate stale statistics</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Index Design</strong></td>
                            <td>
                                <ul class="mb-0">
                                    <li>Composite indexes: equality columns first, then range</li>
                                    <li>Use partial indexes for frequently filtered subsets</li>
                                    <li>Covering indexes eliminate table lookups</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Query Writing</strong></td>
                            <td>
                                <ul class="mb-0">
                                    <li>Avoid functions on indexed columns in WHERE</li>
                                    <li>Replace correlated subqueries with JOINs</li>
                                    <li>Use UNION ALL when duplicates don't matter</li>
                                    <li>Use keyset pagination for large result sets</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Optimization Process</strong></td>
                            <td>
                                <ul class="mb-0">
                                    <li>Measure first with EXPLAIN ANALYZE</li>
                                    <li>Identify the slowest operation</li>
                                    <li>Apply targeted fix (index or rewrite)</li>
                                    <li>Verify improvement with EXPLAIN ANALYZE</li>
                                </ul>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Navigation -->
            <section>
                <div class="d-flex justify-content-between">
                    <a href="01_query_performance_and_optimization.html" class="btn btn-outline-primary">&larr; Back
                        to Lesson</a>
                </div>
            </section>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>

    <script>
        function toggleSolution(id) {
            var element = document.getElementById(id);
            if (element.classList.contains('show')) {
                element.classList.remove('show');
                event.target.textContent = 'Show Solution';
            } else {
                element.classList.add('show');
                event.target.textContent = 'Hide Solution';
            }
        }
    </script>
</body>

</html>
