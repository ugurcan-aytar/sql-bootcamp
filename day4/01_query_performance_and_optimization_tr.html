<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr">


<!-- Mirrored from code-mext.github.io/sql-training/day4/01_query_performance_and_optimization.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 10 Jan 2026 07:44:34 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <link rel="stylesheet" href="../style_bootstrap.html">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/code.css">
  <link href="https://cdn.prod.website-files.com/5efdb54f07a6812bcd95cc65/6773d0fc3013e060f08d7145_favicon.jpg"
    rel="shortcut icon" type="image/x-icon">
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Gun 4: Sorgu Performansi ve Optimizasyon</title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    pre>code.sourceCode {
      white-space: pre;
      position: relative;
    }

    pre>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    pre>code.sourceCode>span:empty {
      height: 1.2em;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      pre>code.sourceCode {
        white-space: pre-wrap;
      }

      pre>code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      color: #aaaaaa;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #aaaaaa;
      padding-left: 4px;
    }

    div.sourceCode {}

    @media screen {
      pre>code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span.al {
      color: #ff0000;
      font-weight: bold;
    }

    /* Alert */
    code span.an {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Annotation */
    code span.at {
      color: #7d9029;
    }

    /* Attribute */
    code span.bn {
      color: #40a070;
    }

    /* BaseN */
    code span.bu {}

    /* BuiltIn */
    code span.cf {
      color: #007020;
      font-weight: bold;
    }

    /* ControlFlow */
    code span.ch {
      color: #4070a0;
    }

    /* Char */
    code span.cn {
      color: #880000;
    }

    /* Constant */
    code span.co {
      color: #60a0b0;
      font-style: italic;
    }

    /* Comment */
    code span.cv {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* CommentVar */
    code span.do {
      color: #ba2121;
      font-style: italic;
    }

    /* Documentation */
    code span.dt {
      color: #902000;
    }

    /* DataType */
    code span.dv {
      color: #40a070;
    }

    /* DecVal */
    code span.er {
      color: #ff0000;
      font-weight: bold;
    }

    /* Error */
    code span.ex {}

    /* Extension */
    code span.fl {
      color: #40a070;
    }

    /* Float */
    code span.fu {
      color: #06287e;
    }

    /* Function */
    code span.im {}

    /* Import */
    code span.in {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Information */
    code span.kw {
      color: #007020;
      font-weight: bold;
    }

    /* Keyword */
    code span.op {
      color: #666666;
    }

    /* Operator */
    code span.ot {
      color: #007020;
    }

    /* Other */
    code span.pp {
      color: #bc7a00;
    }

    /* Preprocessor */
    code span.sc {
      color: #4070a0;
    }

    /* SpecialChar */
    code span.ss {
      color: #bb6688;
    }

    /* SpecialString */
    code span.st {
      color: #4070a0;
    }

    /* String */
    code span.va {
      color: #19177c;
    }

    /* Variable */
    code span.vs {
      color: #4070a0;
    }

    /* VerbatimString */
    code span.wa {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Warning */

    .language-switcher {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background: #fff;
        padding: 5px 10px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .language-switcher a {
        text-decoration: none;
        padding: 5px 10px;
        margin: 0 2px;
        border-radius: 3px;
        color: #333;
    }
    .language-switcher a.active {
        background: #0d6efd;
        color: #fff;
    }
    .language-switcher a:hover:not(.active) {
        background: #e9ecef;
    }
  </style>
</head>

<body>
    <a href="../index_tr.html" class="back-button">← Anasayfaya Don</a>
  <div class="language-switcher">
    <a href="01_query_performance_and_optimization.html">EN</a>
    <a href="01_query_performance_and_optimization_tr.html" class="active">TR</a>
  </div>

  <div class="copy-notification" id="copyNotification">Kopyalandi!</div>

  <div id="europeanunion-turkey">
    <img src="../static/eu.png" alt="">
  </div>
  <div id="sanayiteknolojibakan">
    <img src="../static/sanayitek.png" alt="">
  </div>
  <div id="rekabet">
    <img src="../static/rekabet.png" alt="">
  </div>
  <div id="tisk">
    <img src="../static/tisk.png" alt="">
  </div>
  <div id="undp">
    <img src="../static/undp.png" alt="">
  </div>
  <div class="content-container">
    <div class="container">
      <section>
        <h1 id="day-4-query-performance-and-optimization">Gun 4: Sorgu Performansi ve Optimizasyon</h1>
        <h2 id="session-1-query-performance-and-optimization-2-hours">Sorgu Performansi ve Optimizasyon</h2>
        <p>Dogru sonuclari donduren SQL sorgulari yazmak yalnizca ilk adimdir. Bu sorgularin verimli calismasini saglamak, ozellikle veri hacimleri buyudukce, uygulama performansi icin kritik oneme sahiptir. Bu oturum, veritabanlarinin sorgulari nasil yuruttugununu kesfeder ve sorgu performansini analiz etmek ve optimize etmek icin temel teknikleri tanitir.
        </p>
      </section>
      <section>
        <h3 id="understanding-the-query-optimizer">Sorgu Optimizatorunu Anlamak</h3>
        <p>Her buyuk iliskisel veritabani sistemi, <strong>sorgu optimizatoru</strong> (veya sorgu planlayicisi) olarak adlandirilan sofistike bir bilesen icerir. Gorevi, belirli bir SQL sorgusunu yurutmenin en verimli yolunu bulmaktir.
        </p>
        <div class="row">
          <div class="col-12 col-md-8">
            <p><strong>Genel Optimizator Sureci</strong>:</p>
            <ol type="1">
              <li><strong>Ayristirma (Parsing)</strong>: Veritabani SQL metnini ayristirir, sozdizimini kontrol eder ve dahili bir gosterime (genellikle bir sorgu agaci) donusturur.</li>
              <li><strong>Yeniden Yazma/Donusum</strong>: Optimizator, esdegerlik kurallarina dayali olarak sorgu agacina mantiksal donusumler uygular, potansiyel olarak basitlestirerek veya daha iyi yurutme icin yeniden yapilandirir (ornegin, gorumleri genisletme, yiklemleri asagi itme).</li>
              <li><strong>Plan Olusturma</strong>: Optimizator, birden fazla potansiyel <strong>yurutme plani</strong> olusturur. Yurutme plani, veritabaninin sorgu sonucunu elde etmek icin izleyebilecegi bir dizi adimdir (tablo taramalari, indeks aramalari, birlestirmeler, siralamalar, toplamalar gibi islemler).</li>
              <li><strong>Maliyet Tahmini</strong>: Her potansiyel plan icin, optimizator yurutme <strong>maliyetini</strong> tahmin eder. Bu maliyet, kaynak kullanimini (CPU zamani, G/C islemleri, bellek) temsil eden soyut bir birimdir. Tahmin buyuk olcude sunlara dayanir:
                <ul>
                  <li><strong>Veritabani Istatistikleri</strong>: Tablolar (boyut, satir sayisi) ve sutunlar (veri dagilimi, benzersiz degerler, histogramlar, NULL sayilari) hakkinda bilgi. Dogru, guncel istatistikler iyi plan secimleri icin hayati onem tasir.</li>
                  <li><strong>Maliyet Modeli</strong>: Farkli islemlerin goreceli maliyetini temsil eden dahili parametreler (ornegin, sirali sayfa okuma ile rastgele sayfa okuma karsilastirmasi).</li>
                </ul>
              </li>
              <li><strong>Plan Secimi</strong>: Optimizator, tahmini maliyeti en dusuk olan yurutme planini secer.
              </li>
              <li><strong>Yurutme</strong>: Veritabani secilen plani yurutur.</li>
            </ol>
          </div>
          <div class="col-6 col-md-4">
            <img class="side-image" src="session1_content/sql_query_optimization_process.png"
              alt="sorgu optimizasyon sureci">
          </div>
        </div>
        <p><strong>Optimizatoru Anlamanin Onemi</strong>: Optimizatorler son derece sofistike olsalar da mukemmel degildirler. Tahminler ve sezgisel yontemlerle calisirlar. Temelleri anlamak size yardimci olur:</p>
        <ul>
          <li>Optimizatöre yardimci olacak sekilde sorgular yazmak.</li>
          <li>Performans sorunlarini teshis etmek icin yurutme planlarini yorumlamak.</li>
          <li>Eksik indekslerin veya guncel olmayan istatistiklerin kotu plan secimlerine neden oldugunu belirlemek.</li>
        </ul>
      </section>
      <section>
        <h4 id="analyzing-execution-plans-explain">Yurutme Planlarini Analiz Etme (EXPLAIN)</h4>
        <p>Cogu veritabani, belirli bir sorgu icin optimizator tarafindan secilen yurutme planini <em>aslinda yurutmeden</em> gostermek icin genellikle <code>EXPLAIN</code> (veya varyasyonlari) adinda bir komut saglar.</p>
        <p><strong>Veritabani Istatistikleri</strong>: Veritabani istatistiklerini duzenli olarak guncellemek cok onemlidir. Cogu veritabani otomatik istatistik toplama mekanizmalarina sahiptir, ancak onemli veri degisikliklerinden sonra manuel guncellemeler (PostgreSQL/Oracle'da <code>ANALYZE</code>, SQL Server'da <code>UPDATE STATISTICS</code>, MySQL'de <code>ANALYZE TABLE</code>) gerekli olabilir.
        </p>
        <div class="row">
          <div class="col-12 col-md-8">
            <p><strong>Yaygin Sozdizimi Varyasyonlari</strong>: </p>
            <ul>
              <li><strong>PostgreSQL/MySQL/SQLite</strong>: <code>EXPLAIN SELECT ...;</code></li>
              <li><strong>Oracle</strong>: <code>EXPLAIN PLAN FOR SELECT ...;</code> (ardindan bir plan tablosu sorgulamasi, ornegin <code>SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);</code>)</li>
              <li><strong>SQL Server</strong>: <code>SET SHOWPLAN_TEXT ON; SELECT ...; SET SHOWPLAN_TEXT OFF;</code> (veya <code>SHOWPLAN_ALL</code>, <code>SHOWPLAN_XML</code>, veya SSMS'de grafiksel planlari kullanin).
              </li>
              <li><strong>Db2</strong>: <code>EXPLAIN PLAN FOR SELECT ...;</code> (explain tablolarinin kurulumunu gerektirir).
              </li>
            </ul>
            <p><strong><code>EXPLAIN</code> Ciktisini Yorumlama</strong>: Cikti genellikle bir islemler agaci (dugumler) gosterir. Her dugum icin anahtar bilgiler sunlari icerir:
            <ul>
              <li><strong>Islem Turu</strong>: Gerceklestirilen eylem (ornegin, Tablo Taramasi, Indeks Taramasi, Hash Birlestirme, Siralama, Toplama).</li>
              <li><strong>Hedef Nesne</strong>: Ilgili tablo veya indeks.</li>
              <li><strong>Tahmini Maliyet</strong>: Bu islem ve alt islemleri icin optimizatorun maliyet tahmini.</li>
              <li><strong>Tahmini Satirlar</strong>: Bu islem tarafindan uretilen tahmini satir sayisi.</li>
              <li><strong>Yiklemler/Filtreler</strong>: Bu adimda uygulanan kosullar.</li>
              <li><strong>Birlestirme Kosullari</strong>: Tablolarin nasil baglandigi.</li>
            </ul>
            </p>
          </div>
          <div class="col-6 col-md-4">
            <img class="side-image" style="max-height: 500px;" src="session1_content/sql_explain_procedure.png"
              alt="sql explain proseduru">
          </div>
        </div>
        <p><strong><code>EXPLAIN ANALYZE</code> (veya esdegeri)</strong>: Bazi veritabanlari (ozellikle PostgreSQL) sorguyu <em>yuruterek</em> ve plan ciktisinda tahminlerin yaninda <em>gercek</em> sure ve <em>gercek</em> satir sayilarini iceren gelistirilmis bir surum (<code>EXPLAIN ANALYZE</code>) sunar. Bu, tahminler ve gerceklik arasindaki tutarsizliklari teshis etmek icin cok degerlidir.
        </p>
      </section>
      <section>
        <p><strong>Yaygin Plan Islemleri (Kavramsal)</strong>:</p>
        <ul>
          <li><strong>Tam Tablo Taramasi / Sirali Tarama</strong>: Tablodaki her satiri okur. Kucuk tablolar veya cogu satira erisim gerektiginde verimlidir, ancak yalnizca birkaç satir gerektiginde buyuk tablolar icin genellikle yavasttir.
          </li>
          <li><strong>Indeks Taramasi</strong>: Indeks anahtar degerlerine dayali olarak belirli satirlari hizla bulmak icin bir indeks kullanir. Secici sorgular icin verimlidir.</li>
          <li><strong>Bitmap Indeks Taramasi (PostgreSQL/Oracle)</strong>: Tabloya erismeden once birden fazla indeks aramasinin sonuclarini verimli bir sekilde birlestirir.</li>
          <li><strong>Ic Ice Dongu Birlestirme (Nested Loop Join)</strong>: Dis tablonun satirlari arasinda yineler ve her satir icin eslesmeleri bulmak icin ic tabloyu (genellikle bir indeks araciligiyla) tarar. Kucuk dis tablolar veya ic tablo birlestirmesi bir indeks araciligiyla yuksek secicilige sahip oldugunda iyidir.</li>
          <li><strong>Hash Birlestirme</strong>: Daha kucuk tabloda (birlestirme sutunlarina dayali) bellekte bir hash tablosu olusturur ve ardindan daha buyuk tablodaki satirlarla sorgular. Buyuk tablolar ve esitlik birlestirmeleri icin verimlidir, ancak bellek gerektirir.</li>
          <li><strong>Merge Birlestirme</strong>: Her iki tabloyu birlestirme sutunlarina gore siralar ve ardindan birlestiriri. Tablolar zaten siraliysa veya ciktinin yine de siralanmasi gerekiyorsa verimlidir.</li>
          <li><strong>Siralama</strong>: Satirlari acikca siralar. Ozellikle veriler diske tasarsa pahali olabilir.</li>
          <li><strong>Toplama (Hash/Akis)</strong>: Gruplama islemlerini (<code>GROUP BY</code>, <code>DISTINCT</code>) gerceklestirir. Hash toplama bir hash tablosu olusturur; akis toplama siralanmis girdi gerektirir.
          </li>
        </ul>
        <img class="sub-image" style="width: 100%;" src="session1_content/sql_common_plan_operations.png"
          alt="sql yaygin plan islemleri">
      </section>
      <section>
        <p><strong>Yurutme Planlarinda Uyari Isaretleri</strong>:</p>
        <ul>
          <li>Secici sorgular icin buyuk tablolarda tam tablo taramalari (genellikle eksik indeksleri gosterir).</li>
          <li>Tahmini ve gercek satir sayilari arasinda buyuk tutarsizliklar (guncel olmayan istatistikleri gosterir).</li>
          <li>Belirli islemler icin beklenmedik sekilde yuksek maliyetler.</li>
          <li>Kesinlikle gerekli olmadiginda siralama gibi pahali islemlerin kullanimi.</li>
          <li>Filtrelerin planda erken yerine gec uygulanmasi.</li>
        </ul>
        <img class="sub-image" src="session1_content/sql_optimize_select.png" alt="sql optimize select">

      </section>
      <section>
        <h3 id="indexing-strategies">Indeksleme Stratejileri</h3>
        <p>Indeksler, veritabaninin tum tabloyu taramaktan cok daha hizli bir sekilde belirli kriterlere uyan satirlari bulmasina olanak taniyan veri yapilaridir. Dogru indeksleri secmek genellikle sorgu performansini iyilestirmenin en etkili tek yoludur.</p>
        <p><strong>Yaygin Indeks Turleri</strong>:</p>
        <div class="row">
          <div class="col-md-3">
            <ol type="1">
              <li>
                <p><strong>B-Tree Indeksleri (Dengeli Agac)</strong>:</p>
                <ul>
                  <li>Cogu RDBMS'de varsayilan indeks turudur.</li>
                  <li>Esitlik (<code>=</code>), aralik (<code>&lt;</code>, <code>&gt;</code>, <code>BETWEEN</code>) ve onek (<code>LIKE 'abc%'</code>) aramalari icin mukemmeldir.
                  </li>
                  <li>Siralamaayi (<code>ORDER BY</code>) destekler.</li>
                  <li>Yuksek kardinaliteye (cok sayida benzersiz deger) sahip sutunlarda iyi calisir.</li>
                </ul>
                <div class="sourceCode" id="cb1">
                  <pre
                    class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- Standart B-Tree indeksi</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_orders_order_date <span class="kw">ON</span> orders (order_date);</span></code></pre>
                </div>
              </li>
            </ol>
          </div>
          <div class="col-md-3">
            <ol type="1" start="2">
              <li>
                <p><strong>Hash Indeksleri</strong>:</p>
                <ul>
                  <li><em>Yalnizca</em> esitlik karsilastirmalari (<code>=</code>) icin optimize edilmistir.</li>
                  <li>Tam eslesmelere dayali aramalar icin cok hizlidir.</li>
                  <li>Aralik sorgulari veya siralama icin kullanilamaz.</li>
                  <li>Birçok sistemde B-Tree'lerden daha az yaygin bir birincil indeks turudur.</li>
                </ul>
                <div class="sourceCode" id="cb2">
                  <pre
                    class="sourceCode sql"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">-- Sozdizimi degisir, PostgreSQL icin ornek</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_users_email_hash <span class="kw">ON</span> users <span class="kw">USING</span> <span class="kw">HASH</span> (email);</span></code></pre>
                </div>
              </li>
            </ol>
          </div>
          <div class="col-md-3">
            <ol type="1" start="3">
              <li>
                <p><strong>Bitmap Indeksleri (Oracle, eklenti ile PostgreSQL)</strong>:</p>
                <ul>
                  <li>Veri ambarlarinda dusuk kardinaliteye (az sayida benzersiz deger, ornegin cinsiyet, durum bayraklari) sahip sutunlar icin en uygunudur.</li>
                  <li>Belirli bir degere uyan satirlari temsil etmek icin bitmaplar kullanir.</li>
                  <li>Bitwise islemler kullanarak birden fazla dusuk kardinaliteli sutundaki kosullari birlestirmede cok verimlidir.
                  </li>
                  <li>Yuksek guncelleme (OLTP) ortamlarinda bakim pahali olabilir.</li>
                </ul>
              </li>
            </ol>
          </div>
          <div class="col-md-3">
            <ol type="1" start="4">
              <li>
                <p><strong>Tam Metin Indeksleri</strong>: Metin belgeleri icinde arama yapmak icin ozellestirilmis indeksler (daha sonra ele alinacaktir).</p>
              </li>
              <li>
                <p><strong>Uzamsal Indeksler (GiST/R-Tree)</strong>: Geometrik veya cografik verileri sorgulamak icin (daha sonra ele alinacaktir).
                </p>
              </li>
              <li>
                <p><strong>GIN/Ters Indeksler (PostgreSQL)</strong>: Diziler veya JSONB gibi bilesik turleri indekslemek icin optimize edilmistir, bilesik deger <em>icindeki</em> elemanlarin verimli aramasina olanak tanir.</p>
              </li>
            </ol>
          </div>
        </div>
      </section>
      <section>
        <img class="sub-image" style="width: 100%;" src="session1_content/sql_common_index_types.png"
          alt="sql yaygin indeks turleri">
      </section>
      <section>
        <p><strong>Indeksleme Stratejileri</strong>:</p>
        <div class="row">
          <div class="col-md-6">
            <ol type="1">
              <li>
                <p><strong>Tek Sutun Indeksleri</strong>: <code>WHERE</code> cumleleri veya birlestirme kosullarinda sikca kullanilan tek tek sutunlari indeksleyin.
                </p>
              </li>
              <li>
                <p><strong>Cok Sutunlu (Kompozit) Indeksler</strong>: Birden fazla sutunu birlikte indeksleyin. Sutunlarin sirasi onemlidir!</p>
                <ul>
                  <li><code>(col_a, col_b)</code> uzerindeki bir indeks, yalnizca <code>col_a</code> uzerinde veya <code>col_a AND col_b</code> uzerinde filtreleme yapan sorgulari verimli bir sekilde destekleyebilir.
                  </li>
                  <li>Yalnizca <code>col_b</code> uzerinde filtreleme yapan sorgular icin genellikle <em>daha az</em> verimlidir (veya kullanilamaz).
                  </li>
                  <li><strong>Kilavuz</strong>: Esitlik yiklemlerinde kullanilan sutunlari once, ardindan aralik yiklemlerinde kullanilan sutunlari yerlestirin. Daha secici sutunlari daha once koyun.</li>
                </ul>
                <div class="sourceCode" id="cb3">
                  <pre
                    class="sourceCode sql"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">-- WHERE status = ? AND order_date > ? icin iyi</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_orders_status_date <span class="kw">ON</span> orders (status, order_date);</span></code></pre>
                </div>
              </li>
              <li>
                <p><strong>Benzersiz Indeksler</strong>: Hizli aramalar saglamanin yani sira bir sutunda (veya sutun kumesinde) benzersizligi zorlar. Genellikle alternatif anahtarlar icin kullanilir.</p>
                <div class="sourceCode" id="code10" onclick="CopyToClipboard('code10')">
                  <pre
                    class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE UNIQUE INDEX</span> uq_users_email <span class="kw">ON</span> users (email);</code></pre>
                </div>
              </li>
            </ol>
          </div>
          <div class="col-md-6">
            <ol type="1" start="4">
              <li>
                <p><strong>Kismi Indeksler (PostgreSQL, SQL Server Filtrelenmis Indeksler)</strong>: Yalnizca belirli bir <code>WHERE</code> kosulunu karsilayan satirlarin bir alt kumesini indeksleyin. Yaygin alt kumeleri (ornegin aktif siparisler, odenmemis faturalar) indekslemek icin kullanislidir, indeksi daha kucuk ve daha hizli yapar.</p>
                <div class="sourceCode" id="code11" onclick="CopyToClipboard('code11')">
                  <pre
                    class="sourceCode sql"><code class="sourceCode sql"><span class="co">-- PostgreSQL Ornegi: Yalnizca aktif kullanicilari indeksle</span>
<span class="kw">CREATE INDEX</span> idx_users_active_email <span class="kw">ON</span> users (email) <span class="kw">WHERE</span> is_active = <span class="kw">TRUE</span>;</code></pre>
                </div>
              </li>
              <li>
                <p><strong>Ifade Indeksleri / Fonksiyon Tabanli Indeksler</strong>: Bir veya daha fazla sutuna uygulanan bir fonksiyon veya ifadenin sonucunu indeksleyin. Sorgular sikca bu ifadeye dayali olarak filtreleme veya siralama yaptiginda kullanislidir.</p>
                <div class="sourceCode" id="code8" onclick="CopyToClipboard('code8')">
                  <pre class="sourceCode sql"><code class="sourceCode sql"><span class="co">-- Buyuk/kucuk harf duyarsiz e-posta aramasi icin indeks</span>
<span class="kw">CREATE INDEX</span> idx_users_lower_email <span class="kw">ON</span> users (<span class="fu">LOWER</span>(email));
<span class="co">-- Sorgu sunlari kullanir: WHERE LOWER(email) = 'user@example.com'</span></code></pre>
                </div>
              </li>
              <li>
                <p><strong>Kapsayici Indeksler</strong>: Belirli bir sorgu tarafindan gereken tum sutunlari (indeks anahtarlari veya dahil edilen sutunlar olarak) iceren bir indeks. Veritabaninin tabloya erismeden <em>yalnizca</em> indeksi kullanarak sorguyu yanıtlamasina olanak tanir (Yalnizca Indeks Taramasi).</p>
                <div class="sourceCode" id="code9" onclick="CopyToClipboard('code9')">
                  <pre class="sourceCode sql"><code class="sourceCode sql"><span class="co">-- SQL Server Ornegi dahil edilen sutunlarla</span>
<span class="kw">CREATE INDEX</span> idx_orders_customer_inc_date_total
<span class="kw">ON</span> orders (customer_id) <span class="kw">INCLUDE</span> (order_date, total_amount);
<span class="co">-- Destekler: SELECT order_date, total_amount FROM orders WHERE customer_id = ?</span></code></pre>
                </div>
              </li>
            </ol>
          </div>
        </div>
        <p><strong>Indeksleme Degis Tokuslari</strong>: Indeksler okumalari (<code>SELECT</code>) hizlandirir ancak yazmalari (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) yavaslatir cunku indeksler de guncellenmek zorundadir. Asiri indekslemekten kacinin; yaygin sorgu kaliplarina dayali olarak stratejik indeksler olusturun.</p>
      </section>
      <section>
        <h3 id="common-query-optimization-techniques">Yaygin Sorgu Optimizasyon Teknikleri</h3>
        <p>Indekslemenin yanisira, sorgularinizi nasil yazdiginiz performansi onemli olcude etkileyebilir.</p>
        <div class="row">
          <div class="col-12 col-md-8">
            <ol type="1">
              <li><strong>Spesifik Olun</strong>: Yalnizca ihtiyaciniz olan sutunlari <code>SELECT</code> edin, <code>SELECT *</code> degil.
              </li>
              <li><strong>Erken Filtreleyin</strong>: En fazla satiri filtreleyen <code>WHERE</code> cumlelelerini mumkun oldugunca erken uygulayin.</li>
              <li><strong><code>WHERE</code> Icindeki Indeksli Sutunlarda Fonksiyon Kullanmaktan Kacinin</strong>: <code>WHERE</code> cumlesindeki bir sutuna bir fonksiyon uygulamak, optimizatorun o sutundaki standart bir indeksi kullanmasini genellikle engeller (ornegin, <code>WHERE YEAR(order_date) = 2023</code>). Mumkunse yeniden yazin (ornegin, <code>WHERE order_date &gt;= '2023-01-01' AND order_date &lt; '2024-01-01'</code>) veya bir ifade indeksi kullanin.
              </li>
              <li><strong><code>LIKE</code> Cumlelerini Optimize Edin</strong>: On ek joker karakterlerinden (<code>LIKE '%text'</code>) kacinin cunku genellikle indeks kullanimini engeller. Arka ek joker karakterleri (<code>LIKE 'text%'</code>) genellikle B-Tree indekslerini kullanabilir.
              </li>
              <li><strong><code>UNION</code> ile <code>UNION ALL</code></strong>: Yinelenen satirlari kaldirmaniz gerekmiyorsa <code>UNION ALL</code> kullanin; siralama/hash adimini atladigi icin daha hizlidir.</li>
              <li><strong><code>EXISTS</code> ile <code>IN</code> ile <code>JOIN</code></strong>: Baska bir tabloda varlik kontrolu yapmanin en iyi yolu degisebilir. <code>EXISTS</code> genellikle alt sorgu varlik kontrolleri icin verimlidir. Birlestirilmis tablodan veriye de ihtiyaciniz varsa genellikle <code>JOIN</code> tercih edilir.
              </li>
              <li><strong>Sonuclari Sinirlayin</strong>: Yalnizca sonuclarin bir alt kumesine ihtiyaciniz varsa, ozellikle <code>ORDER BY</code> ile birlestirildiginde <code>LIMIT</code> (veya <code>FETCH FIRST</code>, <code>TOP</code>) kullanin.</li>
              <li><strong>Sayfalama</strong>: <code>LIMIT</code> ve <code>OFFSET</code> kullanarak (veya buyuk offset'lerde daha iyi performans icin anahtar kumesi sayfalamasi) sayfalamayi dikkatli bir sekilde uygulayin.
              </li>
              <li><strong>Iliskili Alt Sorgulardan Kacinin</strong>: Bunlar dis sorgunun her satiri icin bir kez yurutulur ve cok yavas olabilir. Mumkun oldugunda <code>JOIN</code>'ler veya pencere fonksiyonlari kullanarak yeniden yazin.</li>
              <li><strong>Gecici Tablolar/CTE'ler</strong>: Ortak Tablo Ifadeleri (<code>WITH ... AS (...)</code>) veya gecici tablolar kullanarak karmasik sorgulari parcalarin. Bu bazen optimizatöre yardimci olabilir ve okunabilirrligi iyilestirebilir, ancak daha iyi performansi garanti etmez.</li>
            </ol>
          </div>
          <div class="col-6 col-md-4">
            <img class="side-image" style="width: 100%;" src="session1_content/sql_quey_optimization_techniques.png"
              alt="sql sorgu optimizasyon teknikleri">
          </div>

        </div>
        <p><strong>Optimizasyon yinelemeli bir surectir</strong>: Plani analiz edin (<code>EXPLAIN</code>), bir hipotez olusturun (ornegin eksik indeks, guncel olmayan istatistikler), bir degisiklik uygulayin (ornegin <code>CREATE INDEX</code>), etkiyi olcun (<code>EXPLAIN ANALYZE</code>) ve tekrarlayin.</p>
      </section>
      <section>
        <h3 id="practice-exercises">Ogrendiklerinizi Uygulayin</h3>
        <p>Sorgu optimizasyonunda ustalasmaya hazir misiniz? Yurutme planlarini okuma, indeksler tasarlama ve yavas sorgulari yeniden yazma konusunda uygulamali alistirmalarla pratik yapin.</p>
        <p><a href="01_query_performance_and_optimization_examples.html" class="btn btn-primary">Pratik Orneklere Git &rarr;</a></p>
      </section>
    </div>
  </div> <!-- /container -->
</body>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
  integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>


<!-- Mirrored from code-mext.github.io/sql-training/day4/01_query_performance_and_optimization.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 10 Jan 2026 07:44:40 GMT -->
</html>
