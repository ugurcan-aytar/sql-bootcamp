<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/style_bootstrap.css">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/code.css">
    <link href="https://cdn.prod.website-files.com/5efdb54f07a6812bcd95cc65/6773d0fc3013e060f08d7145_favicon.jpg"
        rel="shortcut icon" type="image/x-icon">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Day 2: Working with JSON Data - Practical Examples</title>
    <style>
        code {
            white-space: pre-wrap;
        }

        span.smallcaps {
            font-variant: small-caps;
        }

        span.underline {
            text-decoration: underline;
        }

        div.column {
            display: inline-block;
            vertical-align: top;
            width: 50%;
        }

        div.hanging-indent {
            margin-left: 1.5em;
            text-indent: -1.5em;
        }

        ul.task-list {
            list-style: none;
        }

        .language-switcher {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .language-switcher a {
            text-decoration: none;
            padding: 5px 10px;
            margin: 0 2px;
            border-radius: 3px;
            color: #333;
        }

        .language-switcher a.active {
            background: #0d6efd;
            color: #fff;
        }

        .language-switcher a:hover:not(.active) {
            background: #e9ecef;
        }

        .exercise-box {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .exercise-box h4 {
            color: #495057;
            margin-bottom: 15px;
        }

        .solution-box {
            background-color: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .solution-box.show {
            display: block;
        }

        .toggle-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .toggle-btn:hover {
            background-color: #0056b3;
        }

        .hint-box {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .hint-box::before {
            content: "Hint: ";
            font-weight: bold;
        }

        .warning-box {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .warning-box::before {
            content: "Warning: ";
            font-weight: bold;
        }

        .concept-box {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .concept-box::before {
            content: "Concept: ";
            font-weight: bold;
        }

        .syntax-box {
            background-color: #e2d5f1;
            border: 1px solid #c5b3d9;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .syntax-box::before {
            content: "Syntax Reference: ";
            font-weight: bold;
        }

        .challenge-box {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .challenge-box h4 {
            color: #155724;
        }

        .challenge-box::before {
            content: "";
        }

        .dataset-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 14px;
        }

        .dataset-table th,
        .dataset-table td {
            border: 1px solid #dee2e6;
            padding: 8px 12px;
            text-align: left;
        }

        .dataset-table th {
            background-color: #343a40;
            color: white;
        }

        .dataset-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .comparison-table th,
        .comparison-table td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
        }

        .comparison-table th {
            background-color: #007bff;
            color: white;
        }

        .comparison-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .json-display {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            overflow-x: auto;
            white-space: pre;
        }

        .json-key {
            color: #f92672;
        }

        .json-string {
            color: #a6e22e;
        }

        .json-number {
            color: #ae81ff;
        }

        .json-boolean {
            color: #66d9ef;
        }

        .result-box {
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }

        .db-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            margin: 2px;
        }

        .db-postgresql {
            background-color: #336791;
            color: white;
        }

        .db-mysql {
            background-color: #4479A1;
            color: white;
        }

        .db-sqlserver {
            background-color: #CC2927;
            color: white;
        }

        .db-oracle {
            background-color: #F80000;
            color: white;
        }

        .operator-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 13px;
        }

        .operator-table th,
        .operator-table td {
            border: 1px solid #dee2e6;
            padding: 10px;
            text-align: left;
            vertical-align: top;
        }

        .operator-table th {
            background-color: #6c5ce7;
            color: white;
        }

        .operator-table code {
            background-color: #f1f1f1;
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>

<body>
    <a href="../index_en.html" class="back-button">‚Üê Back to Index</a>
    <div class="language-switcher">
        <a href="03_working_with_json_examples.html" class="active">EN</a>
        <a href="03_working_with_json_examples_tr.html">TR</a>
    </div>
    <div class="copy-notification" id="copyNotification">Copied!</div>

    <div id="europeanunion-turkey">
        <img src="../static/eu.png" alt="">
    </div>
    <div id="sanayiteknolojibakan">
        <img src="../static/sanayitek.png" alt="">
    </div>
    <div id="rekabet">
        <img src="../static/rekabet.png" alt="">
    </div>
    <div id="tisk">
        <img src="../static/tisk.png" alt="">
    </div>
    <div id="undp">
        <img src="../static/undp.png" alt="">
    </div>
    <div class="content-container">
        <div class="container">
            <section>
                <h1 id="json-practical-examples">Working with JSON Data - Practical Examples</h1>
                <p><a href="03_working_with_json.html">&larr; Back to Working with JSON Data Lesson</a></p>
                <p>This page provides hands-on exercises to master JSON operations in SQL. Practice extracting values,
                    searching within JSON, modifying documents, and converting between JSON and relational formats.</p>

                <div class="syntax-box">
                    <strong>PostgreSQL operators:</strong> <code>-></code> (get as JSON), <code>->></code> (get as text), <code>?</code> (key exists), <code>@></code> (contains)<br>
                    <strong>MySQL:</strong> <code>-></code> or <code>JSON_EXTRACT()</code>, <code>->></code> (unquoted), <code>JSON_CONTAINS()</code><br>
                    <strong>SQL Server:</strong> <code>JSON_VALUE()</code>, <code>JSON_QUERY()</code>, <code>OPENJSON()</code>
                </div>
            </section>

            <!-- Sample Datasets Section -->
            <section>
                <h2 id="sample-datasets">Sample Datasets</h2>
                <p>The following tables from <code>bootcamp_db</code> contain JSONB columns. Review these sample records to understand the data structure before starting the exercises.</p>

                <h4>products Table (attributes JSONB column)</h4>
                <p>The <code>attributes</code> column stores product specifications as JSON. Different product types have different attributes (laptops have processor/ram, phones have screen/camera, etc.):</p>
                <table class="dataset-table">
                    <thead>
                        <tr>
                            <th>id</th>
                            <th>name</th>
                            <th>attributes (JSONB)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>ProBook Laptop 15"</td>
                            <td>
                                <div class="json-display">{
  "brand": "TechPro",
  "processor": "Intel i7-12700H",
  "ram": "16GB DDR5",
  "storage": "512GB NVMe SSD",
  "display": "15.6 inch FHD",
  "battery": "72Wh",
  "warranty_months": 24
}</div>
                            </td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>SmartPhone Pro Max</td>
                            <td>
                                <div class="json-display">{
  "brand": "TechMobile",
  "screen": "6.7 inch OLED",
  "storage": "256GB",
  "ram": "12GB",
  "camera": "108MP + 12MP + 10MP",
  "battery": "5000mAh",
  "5g": true,
  "colors": ["Black", "Silver", "Blue"]
}</div>
                            </td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>SmartPhone Lite</td>
                            <td>
                                <div class="json-display">{
  "brand": "TechMobile",
  "screen": "6.1 inch LCD",
  "storage": "64GB",
  "ram": "4GB",
  "camera": "48MP + 2MP",
  "battery": "4000mAh",
  "5g": false
}</div>
                            </td>
                        </tr>
                    </tbody>
                </table>

                <h4>orders Table (metadata JSONB column)</h4>
                <p>The <code>metadata</code> column stores order context information. Note: Not all orders have metadata, and different orders may have different keys (source, campaign, b2b, rep_id, returning_customer):</p>
                <table class="dataset-table">
                    <thead>
                        <tr>
                            <th>id</th>
                            <th>order_number</th>
                            <th>metadata (JSONB)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>ORD-2023-0001</td>
                            <td>
                                <div class="json-display">{
  "source": "website",
  "campaign": "new_year"
}</div>
                            </td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>ORD-2023-0002</td>
                            <td>
                                <div class="json-display">{
  "source": "mobile_app"
}</div>
                            </td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>ORD-2023-0003</td>
                            <td>
                                <div class="json-display">{
  "source": "website",
  "b2b": true
}</div>
                            </td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>ORD-2023-0004</td>
                            <td>
                                <div class="json-display">{
  "source": "sales_rep",
  "rep_id": 10
}</div>
                            </td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>ORD-2023-0008</td>
                            <td>
                                <div class="json-display">{
  "source": "website",
  "returning_customer": true
}</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- JSON Operators Quick Reference -->
            <section>
                <h2 id="operator-reference">JSON Operators Quick Reference</h2>
                <table class="operator-table">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th><span class="db-badge db-postgresql">PostgreSQL</span></th>
                            <th><span class="db-badge db-mysql">MySQL</span></th>
                            <th><span class="db-badge db-sqlserver">SQL Server</span></th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Get field as JSON</td>
                            <td><code>data->'field'</code></td>
                            <td><code>data->'$.field'</code></td>
                            <td><code>JSON_QUERY(data, '$.field')</code></td>
                        </tr>
                        <tr>
                            <td>Get field as text</td>
                            <td><code>data->>'field'</code></td>
                            <td><code>data->>'$.field'</code></td>
                            <td><code>JSON_VALUE(data, '$.field')</code></td>
                        </tr>
                        <tr>
                            <td>Get nested path</td>
                            <td><code>data#>>'{a,b,c}'</code></td>
                            <td><code>data->>'$.a.b.c'</code></td>
                            <td><code>JSON_VALUE(data, '$.a.b.c')</code></td>
                        </tr>
                        <tr>
                            <td>Get array element</td>
                            <td><code>data->'arr'->0</code></td>
                            <td><code>data->'$.arr[0]'</code></td>
                            <td><code>JSON_VALUE(data, '$.arr[0]')</code></td>
                        </tr>
                        <tr>
                            <td>Key exists</td>
                            <td><code>data ? 'key'</code></td>
                            <td><code>JSON_CONTAINS_PATH(data, 'one', '$.key')</code></td>
                            <td><code>JSON_VALUE(data, '$.key') IS NOT NULL</code></td>
                        </tr>
                        <tr>
                            <td>Contains value</td>
                            <td><code>data @> '{"k":"v"}'</code></td>
                            <td><code>JSON_CONTAINS(data, '"v"', '$.k')</code></td>
                            <td>Extract and compare</td>
                        </tr>
                        <tr>
                            <td>Set/update value</td>
                            <td><code>jsonb_set(data, '{k}', '"v"')</code></td>
                            <td><code>JSON_SET(data, '$.k', 'v')</code></td>
                            <td><code>JSON_MODIFY(data, '$.k', 'v')</code></td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Exercise 1: Basic JSON Extraction -->
            <section>
                <h2 id="exercise-1">Exercise 1: Basic JSON Path Navigation</h2>
                <p>Learn to extract values from JSON columns using path navigation operators. These are the fundamental operations you'll use in almost every JSON query.</p>

                <div class="concept-box">
                    Use <code>-></code> to get JSON/JSONB output, use <code>->></code> to get text output.
                    The difference matters when comparing values or using in WHERE clauses. Text output is needed for string comparisons and display.
                </div>

                <div class="exercise-box">
                    <h4>Exercise 1.1: Extract Simple Fields</h4>
                    <p>Using the <code>products</code> table with <code>attributes</code> JSONB column, write queries to extract scalar values from JSON:</p>
                    <ol>
                        <li><strong>Brand extraction:</strong> List all product names with their brand (extracted from the <code>brand</code> key in attributes). Only include products that have attributes.</li>
                        <li><strong>RAM specification:</strong> Show product names alongside their RAM specification from the <code>ram</code> key.</li>
                        <li><strong>Warranty filtering:</strong> Find products with warranty longer than 12 months. The <code>warranty_months</code> key stores an integer value.</li>
                    </ol>

                    <div class="hint-box">
                        JSON values are extracted as text by default. To compare numeric values, cast them: <code>(attributes->>'warranty_months')::INTEGER > 12</code>
                    </div>

                    <button class="toggle-btn" onclick="toggleSolution('solution1_1')">Show Solution</button>
                    <div id="solution1_1" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Get brand of all products
SELECT name, attributes->>'brand' AS brand
FROM products
WHERE attributes IS NOT NULL;

-- 2. Get product name and RAM
SELECT name, attributes->>'ram' AS ram
FROM products
WHERE attributes IS NOT NULL;

-- 3. Products with warranty > 12 months
SELECT name, attributes->>'warranty_months' AS warranty
FROM products
WHERE attributes IS NOT NULL
  AND (attributes->>'warranty_months')::INTEGER > 12;

-- MySQL
-- 1. Get brand
SELECT name, attributes->>'$.brand' AS brand
FROM products
WHERE attributes IS NOT NULL;

-- 2. Get product name and RAM
SELECT name, attributes->>'$.ram' AS ram
FROM products
WHERE attributes IS NOT NULL;

-- 3. Products with warranty > 12 months
SELECT name, attributes->>'$.warranty_months' AS warranty
FROM products
WHERE attributes IS NOT NULL
  AND CAST(attributes->>'$.warranty_months' AS UNSIGNED) > 12;

-- SQL Server
-- 1. Get brand
SELECT name, JSON_VALUE(attributes, '$.brand') AS brand
FROM products
WHERE attributes IS NOT NULL;

-- 2. Get product name and RAM
SELECT name, JSON_VALUE(attributes, '$.ram') AS ram
FROM products
WHERE attributes IS NOT NULL;

-- 3. Products with warranty > 12 months
SELECT name, JSON_VALUE(attributes, '$.warranty_months') AS warranty
FROM products
WHERE attributes IS NOT NULL
  AND CAST(JSON_VALUE(attributes, '$.warranty_months') AS INT) > 12;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 1.2: Extract from Orders Metadata</h4>
                    <p>Using the <code>orders</code> table with <code>metadata</code> JSONB column, practice extracting values and filtering by JSON content:</p>
                    <ol>
                        <li><strong>Source extraction:</strong> List all order numbers with their source channel (from the <code>source</code> key). Note: Some orders may have NULL metadata.</li>
                        <li><strong>Campaign orders:</strong> Find orders that have a <code>campaign</code> field in their metadata and display the campaign name.</li>
                        <li><strong>Website orders:</strong> Filter to show only orders where the source equals 'website'.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution1_2')">Show Solution</button>
                    <div id="solution1_2" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Get order source
SELECT order_number, metadata->>'source' AS source
FROM orders
WHERE metadata IS NOT NULL;

-- 2. Get orders with campaign field
SELECT order_number, metadata->>'campaign' AS campaign
FROM orders
WHERE metadata ? 'campaign';

-- 3. Find orders from website
SELECT order_number, metadata->>'source' AS source
FROM orders
WHERE metadata->>'source' = 'website';

-- MySQL
-- 1. Get order source
SELECT order_number, metadata->>'$.source' AS source
FROM orders
WHERE metadata IS NOT NULL;

-- 2. Get orders with campaign field
SELECT order_number, metadata->>'$.campaign' AS campaign
FROM orders
WHERE JSON_CONTAINS_PATH(metadata, 'one', '$.campaign');

-- 3. Find orders from website
SELECT order_number, metadata->>'$.source' AS source
FROM orders
WHERE metadata->>'$.source' = 'website';

-- SQL Server
-- 1. Get order source
SELECT order_number, JSON_VALUE(metadata, '$.source') AS source
FROM orders
WHERE metadata IS NOT NULL;

-- 2. Get orders with campaign field
SELECT order_number, JSON_VALUE(metadata, '$.campaign') AS campaign
FROM orders
WHERE JSON_VALUE(metadata, '$.campaign') IS NOT NULL;

-- 3. Find orders from website
SELECT order_number, JSON_VALUE(metadata, '$.source') AS source
FROM orders
WHERE JSON_VALUE(metadata, '$.source') = 'website';</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 1.3: Access Array Elements</h4>
                    <p>Some products (like smartphones) have a <code>colors</code> array in their attributes. Practice working with JSON arrays:</p>
                    <ol>
                        <li><strong>First element:</strong> Extract the first color (index 0) from products that have a colors array. Array indexing starts at 0.</li>
                        <li><strong>Full array:</strong> Return the entire colors array as JSON for each product.</li>
                        <li><strong>Array length:</strong> Count how many color options each product has using <code>jsonb_array_length()</code>.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution1_3')">Show Solution</button>
                    <div id="solution1_3" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Get first color
SELECT name, attributes->'colors'->>0 AS first_color
FROM products
WHERE attributes ? 'colors';

-- 2. Get all colors as JSON array
SELECT name, attributes->'colors' AS colors
FROM products
WHERE attributes ? 'colors';

-- 3. Count colors
SELECT name, jsonb_array_length(attributes->'colors') AS color_count
FROM products
WHERE attributes ? 'colors';

-- MySQL
-- 1. Get first color
SELECT name, attributes->>'$.colors[0]' AS first_color
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.colors');

-- 2. Get all colors as JSON array
SELECT name, attributes->'$.colors' AS colors
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.colors');

-- 3. Count colors
SELECT name, JSON_LENGTH(attributes->'$.colors') AS color_count
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.colors');

-- SQL Server
-- 1. Get first color
SELECT name, JSON_VALUE(attributes, '$.colors[0]') AS first_color
FROM products
WHERE JSON_QUERY(attributes, '$.colors') IS NOT NULL;

-- 2. Get all colors as JSON array
SELECT name, JSON_QUERY(attributes, '$.colors') AS colors
FROM products
WHERE JSON_QUERY(attributes, '$.colors') IS NOT NULL;

-- 3. Count colors (requires OPENJSON)
SELECT name,
       (SELECT COUNT(*) FROM OPENJSON(attributes, '$.colors')) AS color_count
FROM products
WHERE JSON_QUERY(attributes, '$.colors') IS NOT NULL;</code></pre>
                    </div>
                </div>
            </section>

            <!-- Exercise 2: Existence and Containment Checks -->
            <section>
                <h2 id="exercise-2">Exercise 2: Existence and Containment Checks</h2>
                <p>Learn to check for key existence and value containment in JSON data. These operations are essential for querying semi-structured data where not all records have the same fields.</p>

                <div class="concept-box">
                    PostgreSQL's <code>?</code> checks if a key exists. <code>@></code> checks if the left JSON contains the right JSON (useful for matching specific values).
                    Both operators are efficient when combined with GIN indexes.
                </div>

                <div class="exercise-box">
                    <h4>Exercise 2.1: Check Key Existence</h4>
                    <p>Not all products have the same attributes (laptops don't have 5g, phones don't have warranty_months). Use the <code>?</code> operator to find records with specific keys:</p>
                    <ol>
                        <li><strong>5G capability:</strong> Find all products that have a "5g" field defined in their attributes (regardless of its value).</li>
                        <li><strong>Warranty info:</strong> Find products that have warranty information (the "warranty_months" key exists).</li>
                        <li><strong>Campaign tracking:</strong> Find orders where a "campaign" field was recorded in metadata.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution2_1')">Show Solution</button>
                    <div id="solution2_1" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Products with 5g field
SELECT name, attributes->>'5g' AS has_5g
FROM products
WHERE attributes ? '5g';

-- 2. Products with warranty_months field
SELECT name, attributes->>'warranty_months' AS warranty
FROM products
WHERE attributes ? 'warranty_months';

-- 3. Orders with campaign field
SELECT order_number, metadata->>'campaign' AS campaign
FROM orders
WHERE metadata ? 'campaign';

-- MySQL
-- 1. Products with 5g field
SELECT name, attributes->>'$.5g' AS has_5g
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.5g');

-- 2. Products with warranty_months field
SELECT name, attributes->>'$.warranty_months' AS warranty
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.warranty_months');

-- 3. Orders with campaign field
SELECT order_number, metadata->>'$.campaign' AS campaign
FROM orders
WHERE JSON_CONTAINS_PATH(metadata, 'one', '$.campaign');

-- SQL Server
-- 1. Products with 5g field
SELECT name, JSON_VALUE(attributes, '$.5g') AS has_5g
FROM products
WHERE JSON_VALUE(attributes, '$.5g') IS NOT NULL;

-- 2. Products with warranty_months field
SELECT name, JSON_VALUE(attributes, '$.warranty_months') AS warranty
FROM products
WHERE JSON_VALUE(attributes, '$.warranty_months') IS NOT NULL;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 2.2: Containment Queries</h4>
                    <p>Use the <code>@></code> containment operator to find records matching specific JSON values. This is more efficient than extracting and comparing:</p>
                    <ol>
                        <li><strong>5G phones:</strong> Find products where 5g is set to true (not just where the key exists, but where the value is true).</li>
                        <li><strong>Brand filter:</strong> Find all products from the "TechMobile" brand using containment.</li>
                        <li><strong>B2B orders:</strong> Find business-to-business orders where metadata contains <code>{"b2b": true}</code>.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution2_2')">Show Solution</button>
                    <div id="solution2_2" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Products with 5G support
SELECT name, attributes
FROM products
WHERE attributes @> '{"5g": true}'::jsonb;

-- Alternative using text extraction and cast
SELECT name
FROM products
WHERE (attributes->>'5g')::BOOLEAN = TRUE;

-- 2. Products from TechMobile brand
SELECT name, attributes->>'brand' AS brand
FROM products
WHERE attributes @> '{"brand": "TechMobile"}'::jsonb;

-- 3. B2B orders
SELECT order_number, metadata
FROM orders
WHERE metadata @> '{"b2b": true}'::jsonb;

-- MySQL
-- 1. Products with 5G support
SELECT name, attributes
FROM products
WHERE JSON_EXTRACT(attributes, '$.5g') = true;

-- 2. Products from TechMobile brand
SELECT name, attributes->>'$.brand' AS brand
FROM products
WHERE JSON_CONTAINS(attributes, '"TechMobile"', '$.brand');

-- 3. B2B orders
SELECT order_number, metadata
FROM orders
WHERE JSON_EXTRACT(metadata, '$.b2b') = true;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 2.3: Multiple Key Existence</h4>
                    <p>PostgreSQL provides <code>?&</code> (all keys exist) and <code>?|</code> (any key exists) for checking multiple keys at once:</p>
                    <ol>
                        <li><strong>AND logic:</strong> Find products that have BOTH "5g" AND "colors" fields (smartphones with color options).</li>
                        <li><strong>OR logic:</strong> Find products that have EITHER "warranty_months" OR "colors" fields (products with extended info).</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution2_3')">Show Solution</button>
                    <div id="solution2_3" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Products with BOTH 5g AND colors
SELECT name
FROM products
WHERE attributes ?& ARRAY['5g', 'colors'];

-- Alternative using AND
SELECT name
FROM products
WHERE attributes ? '5g' AND attributes ? 'colors';

-- 2. Products with EITHER warranty_months OR colors
SELECT name
FROM products
WHERE attributes ?| ARRAY['warranty_months', 'colors'];

-- Alternative using OR
SELECT name
FROM products
WHERE attributes ? 'warranty_months' OR attributes ? 'colors';

-- MySQL
-- 1. Products with BOTH
SELECT name
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'all', '$.5g', '$.colors');

-- 2. Products with EITHER
SELECT name
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.warranty_months', '$.colors');</code></pre>
                    </div>
                </div>
            </section>

            <!-- Exercise 3: Modifying JSON Data -->
            <section>
                <h2 id="exercise-3">Exercise 3: Modifying JSON Data</h2>
                <p>Learn to update, add, and remove fields from JSON documents. These UPDATE queries demonstrate how to modify specific parts of a JSON column.</p>

                <div class="warning-box">
                    Modifying JSON updates the entire document internally. For frequently updated fields,
                    consider storing them in separate relational columns for better performance.
                </div>

                <div class="exercise-box">
                    <h4>Exercise 3.1: Update JSON Fields</h4>
                    <p>Use <code>jsonb_set()</code> and the <code>||</code> merge operator to modify JSON values:</p>
                    <ol>
                        <li><strong>Update existing value:</strong> Change warranty_months from 24 to 36 for 'ProBook Laptop 15"' using <code>jsonb_set()</code>.</li>
                        <li><strong>Add new field:</strong> Add an "eco_friendly" field with value true to a product's attributes using the <code>||</code> merge operator.</li>
                        <li><strong>Extend metadata:</strong> Add a "priority" field with value "high" to order id=1 metadata.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution3_1')">Show Solution</button>
                    <div id="solution3_1" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Update warranty_months
UPDATE products
SET attributes = jsonb_set(attributes, '{warranty_months}', '36')
WHERE name = 'ProBook Laptop 15"';

-- 2. Add eco_friendly field
UPDATE products
SET attributes = attributes || '{"eco_friendly": true}'::jsonb
WHERE name = 'ProBook Laptop 15"';

-- Alternative using jsonb_set
UPDATE products
SET attributes = jsonb_set(attributes, '{eco_friendly}', 'true')
WHERE name = 'ProBook Laptop 15"';

-- 3. Add priority to order metadata
UPDATE orders
SET metadata = metadata || '{"priority": "high"}'::jsonb
WHERE id = 1;

-- MySQL
-- 1. Update warranty_months
UPDATE products
SET attributes = JSON_SET(attributes, '$.warranty_months', 36)
WHERE name = 'ProBook Laptop 15"';

-- 2. Add eco_friendly field
UPDATE products
SET attributes = JSON_SET(attributes, '$.eco_friendly', true)
WHERE name = 'ProBook Laptop 15"';

-- 3. Add priority to order metadata
UPDATE orders
SET metadata = JSON_SET(metadata, '$.priority', 'high')
WHERE id = 1;

-- SQL Server
-- 1. Update warranty_months
UPDATE products
SET attributes = JSON_MODIFY(attributes, '$.warranty_months', 36)
WHERE name = 'ProBook Laptop 15"';

-- 2. Add eco_friendly field
UPDATE products
SET attributes = JSON_MODIFY(attributes, '$.eco_friendly', CAST('true' AS BIT))
WHERE name = 'ProBook Laptop 15"';

-- 3. Add priority to order metadata
UPDATE orders
SET metadata = JSON_MODIFY(metadata, '$.priority', 'high')
WHERE id = 1;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 3.2: Remove JSON Fields</h4>
                    <p>Use the <code>-</code> operator to remove keys from JSONB (or <code>#-</code> for nested paths):</p>
                    <ol>
                        <li><strong>Remove product field:</strong> Remove the "battery" field from 'SmartPhone Lite' attributes.</li>
                        <li><strong>Remove metadata field:</strong> Remove the "campaign" field from order id=1 metadata.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution3_2')">Show Solution</button>
                    <div id="solution3_2" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Remove battery field from product
UPDATE products
SET attributes = attributes - 'battery'
WHERE name = 'SmartPhone Lite';

-- 2. Remove campaign from order metadata
UPDATE orders
SET metadata = metadata - 'campaign'
WHERE id = 1;

-- Alternative using #- for nested paths
UPDATE orders
SET metadata = metadata #- '{campaign}'
WHERE id = 1;

-- MySQL
-- 1. Remove battery field
UPDATE products
SET attributes = JSON_REMOVE(attributes, '$.battery')
WHERE name = 'SmartPhone Lite';

-- 2. Remove campaign from order metadata
UPDATE orders
SET metadata = JSON_REMOVE(metadata, '$.campaign')
WHERE id = 1;

-- SQL Server
-- 1. Remove battery field (set to null)
UPDATE products
SET attributes = JSON_MODIFY(attributes, '$.battery', NULL)
WHERE name = 'SmartPhone Lite';

-- 2. Remove campaign from order metadata
UPDATE orders
SET metadata = JSON_MODIFY(metadata, '$.campaign', NULL)
WHERE id = 1;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 3.3: Array Modifications</h4>
                    <p>Modifying JSON arrays requires special techniques. Use <code>jsonb_set()</code> combined with array concatenation:</p>
                    <ol>
                        <li><strong>Append to array:</strong> Add "Gold" to the end of 'SmartPhone Pro Max' colors array (currently has ["Black", "Silver", "Blue"]).</li>
                        <li><strong>Replace array:</strong> Replace the entire colors array with ["Red", "Green", "Blue"] for a product.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution3_3')">Show Solution</button>
                    <div id="solution3_3" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Add new color to array
UPDATE products
SET attributes = jsonb_set(
    attributes,
    '{colors}',
    (attributes->'colors') || '"Gold"'::jsonb
)
WHERE name = 'SmartPhone Pro Max';

-- Alternative: concatenate arrays
UPDATE products
SET attributes = jsonb_set(
    attributes,
    '{colors}',
    attributes->'colors' || '["Gold"]'::jsonb
)
WHERE name = 'SmartPhone Pro Max';

-- 2. Replace entire colors array
UPDATE products
SET attributes = jsonb_set(
    attributes,
    '{colors}',
    '["Red", "Green", "Blue"]'::jsonb
)
WHERE name = 'SmartPhone Pro Max';

-- MySQL
-- 1. Add new color (MySQL 8.0+)
UPDATE products
SET attributes = JSON_ARRAY_APPEND(attributes, '$.colors', 'Gold')
WHERE name = 'SmartPhone Pro Max';

-- 2. Replace entire colors array
UPDATE products
SET attributes = JSON_SET(
    attributes,
    '$.colors',
    JSON_ARRAY('Red', 'Green', 'Blue')
)
WHERE name = 'SmartPhone Pro Max';

-- SQL Server (requires rebuilding array)
-- 1. Add new color to array
UPDATE products
SET attributes = JSON_MODIFY(
    attributes,
    '$.colors',
    JSON_QUERY(
        CONCAT(
            LEFT(JSON_QUERY(attributes, '$.colors'),
                 LEN(JSON_QUERY(attributes, '$.colors')) - 1),
            ',"Gold"]'
        )
    )
)
WHERE name = 'SmartPhone Pro Max';</code></pre>
                    </div>
                </div>
            </section>

            <!-- Exercise 4: JSON to Relational Conversion -->
            <section>
                <h2 id="exercise-4">Exercise 4: Converting JSON to Relational Format</h2>
                <p>Learn to expand JSON arrays and objects into rows and columns. This is useful for joining JSON data with relational tables or for reporting.</p>

                <div class="concept-box">
                    <code>jsonb_array_elements()</code> expands a JSON array into rows (one row per element).
                    <code>jsonb_each()</code> expands a JSON object into key-value pairs.
                    MySQL uses <code>JSON_TABLE</code>, SQL Server uses <code>OPENJSON</code>.
                </div>

                <div class="exercise-box">
                    <h4>Exercise 4.1: Expand JSON Arrays</h4>
                    <p>Smartphones have a colors array. Expand this so each color becomes its own row:</p>
                    <p><strong>Goal:</strong> If a product has colors ["Black", "Silver", "Blue"], produce 3 rows - one for each color, alongside the product name.</p>

                    <button class="toggle-btn" onclick="toggleSolution('solution4_1')">Show Solution</button>
                    <div id="solution4_1" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
SELECT
    name,
    jsonb_array_elements_text(attributes->'colors') AS color
FROM products
WHERE attributes ? 'colors';

-- With index position
SELECT
    name,
    ordinality AS color_position,
    color
FROM products,
     jsonb_array_elements_text(attributes->'colors')
     WITH ORDINALITY AS t(color, ordinality)
WHERE attributes ? 'colors';

-- MySQL
SELECT
    name,
    jt.color
FROM products,
     JSON_TABLE(attributes, '$.colors[*]' COLUMNS(
         color VARCHAR(50) PATH '$'
     )) AS jt
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.colors');

-- SQL Server
SELECT
    name,
    color.value AS color
FROM products
CROSS APPLY OPENJSON(attributes, '$.colors') AS color
WHERE JSON_QUERY(attributes, '$.colors') IS NOT NULL;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 4.2: JSON Object to Key-Value Pairs</h4>
                    <p>Expand the entire attributes object into rows where each row shows a key-value pair:</p>
                    <p><strong>Goal:</strong> For a product with {"brand": "TechPro", "ram": "16GB"}, produce 2 rows: (product_name, "brand", "TechPro") and (product_name, "ram", "16GB").</p>

                    <button class="toggle-btn" onclick="toggleSolution('solution4_2')">Show Solution</button>
                    <div id="solution4_2" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
SELECT
    name AS product_name,
    attr.key AS attribute_name,
    attr.value AS attribute_value
FROM products,
     jsonb_each(attributes) AS attr(key, value)
WHERE attributes IS NOT NULL
LIMIT 20;

-- Filter to only scalar values (exclude arrays)
SELECT
    name AS product_name,
    attr.key AS attribute_name,
    attr.value AS attribute_value
FROM products,
     jsonb_each(attributes) AS attr(key, value)
WHERE attributes IS NOT NULL
  AND jsonb_typeof(attr.value) != 'array';

-- MySQL (using specific keys)
SELECT
    name AS product_name,
    'brand' AS attribute_name,
    attributes->>'$.brand' AS attribute_value
FROM products
WHERE attributes IS NOT NULL
UNION ALL
SELECT
    name,
    'processor',
    attributes->>'$.processor'
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.processor')
UNION ALL
SELECT
    name,
    'ram',
    attributes->>'$.ram'
FROM products
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.ram');

-- SQL Server
SELECT
    name AS product_name,
    attr.[key] AS attribute_name,
    attr.[value] AS attribute_value
FROM products
CROSS APPLY OPENJSON(attributes) AS attr
WHERE attributes IS NOT NULL;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 4.3: Expand Order Metadata</h4>
                    <p>Expand order metadata into key-value pairs for analysis:</p>
                    <p><strong>Goal:</strong> For an order with {"source": "website", "campaign": "new_year"}, produce rows showing each metadata key and its value alongside the order_number.</p>

                    <button class="toggle-btn" onclick="toggleSolution('solution4_3')">Show Solution</button>
                    <div id="solution4_3" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
SELECT
    order_number,
    meta.key AS metadata_key,
    meta.value AS metadata_value
FROM orders,
     jsonb_each(metadata) AS meta(key, value)
WHERE metadata IS NOT NULL;

-- Get text values instead of JSON
SELECT
    order_number,
    meta.key AS metadata_key,
    meta.value::TEXT AS metadata_value
FROM orders,
     jsonb_each_text(metadata) AS meta(key, value)
WHERE metadata IS NOT NULL;

-- SQL Server
SELECT
    order_number,
    meta.[key] AS metadata_key,
    meta.[value] AS metadata_value
FROM orders
CROSS APPLY OPENJSON(metadata) AS meta
WHERE metadata IS NOT NULL;</code></pre>
                    </div>
                </div>
            </section>

            <!-- Exercise 5: Building JSON from Relational Data -->
            <section>
                <h2 id="exercise-5">Exercise 5: Building JSON from Relational Data</h2>
                <p>Learn to construct JSON objects and arrays from relational query results. Useful for APIs and data export.</p>

                <div class="exercise-box">
                    <h4>Exercise 5.1: Build JSON Objects</h4>
                    <p>Use <code>jsonb_build_object()</code> to create custom JSON structures from query results:</p>
                    <p><strong>Goal:</strong> Create a JSON object for each product containing: product_name, sku, brand (from attributes), and price.</p>

                    <button class="toggle-btn" onclick="toggleSolution('solution5_1')">Show Solution</button>
                    <div id="solution5_1" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
SELECT
    jsonb_build_object(
        'product_name', name,
        'sku', sku,
        'brand', attributes->>'brand',
        'price', price,
        'has_5g', COALESCE((attributes->>'5g')::BOOLEAN, false)
    ) AS product_json
FROM products
WHERE attributes IS NOT NULL;

-- With pretty formatting
SELECT
    jsonb_pretty(
        jsonb_build_object(
            'product_name', name,
            'brand', attributes->>'brand',
            'price', price
        )
    ) AS product_json
FROM products
WHERE attributes IS NOT NULL;

-- MySQL
SELECT
    JSON_OBJECT(
        'product_name', name,
        'sku', sku,
        'brand', attributes->>'$.brand',
        'price', price
    ) AS product_json
FROM products
WHERE attributes IS NOT NULL;

-- SQL Server
SELECT
    name AS product_name,
    sku,
    JSON_VALUE(attributes, '$.brand') AS brand,
    price
FROM products
WHERE attributes IS NOT NULL
FOR JSON PATH;</code></pre>
                    </div>
                </div>

                <div class="exercise-box">
                    <h4>Exercise 5.2: Aggregate into JSON Arrays</h4>
                    <p>Use <code>jsonb_agg()</code> to aggregate multiple rows into a JSON array, and <code>jsonb_object_agg()</code> to create key-value aggregations:</p>
                    <ol>
                        <li><strong>Simple array:</strong> Create a single JSON array containing all product names.</li>
                        <li><strong>Grouped aggregation:</strong> Group products by brand and create a JSON array of product objects for each brand.</li>
                        <li><strong>Key-value aggregation:</strong> Create a JSON object showing order sources as keys and their counts as values.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('solution5_2')">Show Solution</button>
                    <div id="solution5_2" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. All product names as JSON array
SELECT jsonb_agg(name) AS all_products
FROM products
WHERE attributes IS NOT NULL;

-- 2. Products grouped by brand
SELECT
    attributes->>'brand' AS brand,
    jsonb_agg(
        jsonb_build_object(
            'name', name,
            'price', price,
            'sku', sku
        )
    ) AS products_by_brand
FROM products
WHERE attributes IS NOT NULL
  AND attributes->>'brand' IS NOT NULL
GROUP BY attributes->>'brand';

-- 3. Order sources with counts as JSON
SELECT
    jsonb_object_agg(
        source,
        order_count
    ) AS source_summary
FROM (
    SELECT
        metadata->>'source' AS source,
        COUNT(*) AS order_count
    FROM orders
    WHERE metadata IS NOT NULL
      AND metadata->>'source' IS NOT NULL
    GROUP BY metadata->>'source'
) AS source_counts;

-- MySQL
-- 1. All product names as JSON array
SELECT JSON_ARRAYAGG(name) AS all_products
FROM products
WHERE attributes IS NOT NULL;

-- 2. Products grouped by brand
SELECT
    attributes->>'$.brand' AS brand,
    JSON_ARRAYAGG(
        JSON_OBJECT(
            'name', name,
            'price', price,
            'sku', sku
        )
    ) AS products_by_brand
FROM products
WHERE attributes IS NOT NULL
GROUP BY attributes->>'$.brand';

-- SQL Server
-- 1. All product names as JSON array
SELECT name
FROM products
WHERE attributes IS NOT NULL
FOR JSON PATH;</code></pre>
                    </div>
                </div>
            </section>

            <!-- Challenge Exercises -->
            <section>
                <h2 id="challenge-exercises">Challenge Exercises</h2>
                <p>Apply everything you've learned in these real-world analytics scenarios. These challenges combine multiple JSON operations.</p>

                <div class="challenge-box">
                    <h4>Challenge 1: Order Source Analysis</h4>
                    <p>Analyze order data using the <code>metadata</code> JSONB column. The metadata contains source channel info (website, mobile_app, sales_rep), campaign names, and B2B flags:</p>
                    <ol>
                        <li><strong>Channel distribution:</strong> Count how many orders came from each source channel.</li>
                        <li><strong>B2B orders:</strong> Find all business-to-business orders (b2b = true) and display their total amounts.</li>
                        <li><strong>Marketing campaigns:</strong> List all orders that have a campaign field and show the campaign name.</li>
                        <li><strong>Revenue by channel:</strong> Calculate total revenue, order count, and average order value for each source.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('challenge1')">Show Solution</button>
                    <div id="challenge1" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Count orders by source
SELECT
    metadata->>'source' AS source,
    COUNT(*) AS order_count
FROM orders
WHERE metadata IS NOT NULL
GROUP BY metadata->>'source'
ORDER BY order_count DESC;

-- 2. B2B orders with totals
SELECT
    order_number,
    customer_id,
    total_amount,
    metadata
FROM orders
WHERE metadata @> '{"b2b": true}'::jsonb;

-- 3. Orders with campaigns
SELECT
    order_number,
    metadata->>'campaign' AS campaign_name,
    order_date,
    total_amount
FROM orders
WHERE metadata ? 'campaign';

-- 4. Total revenue by source
SELECT
    metadata->>'source' AS source,
    SUM(total_amount) AS total_revenue,
    COUNT(*) AS order_count,
    ROUND(AVG(total_amount), 2) AS avg_order_value
FROM orders
WHERE metadata IS NOT NULL
GROUP BY metadata->>'source'
ORDER BY total_revenue DESC;</code></pre>
                    </div>
                </div>

                <div class="challenge-box">
                    <h4>Challenge 2: Product Analytics</h4>
                    <p>Analyze product catalog using the <code>attributes</code> JSONB column. Products have varying attributes like brand, 5g support, warranty_months, colors, etc.:</p>
                    <ol>
                        <li><strong>Brand inventory:</strong> Count how many products each brand has in the catalog.</li>
                        <li><strong>5G products:</strong> List all 5G-enabled products with their names, prices, and storage specifications.</li>
                        <li><strong>Brand list:</strong> Get a distinct list of all brands available in the product catalog.</li>
                        <li><strong>Extended warranty:</strong> Find products with warranty longer than 12 months and show warranty duration.</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('challenge2')">Show Solution</button>
                    <div id="challenge2" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Count products by brand
SELECT
    attributes->>'brand' AS brand,
    COUNT(*) AS product_count
FROM products
WHERE attributes IS NOT NULL
  AND attributes->>'brand' IS NOT NULL
GROUP BY attributes->>'brand'
ORDER BY product_count DESC;

-- 2. Products with 5G and prices
SELECT
    name,
    price,
    attributes->>'brand' AS brand,
    attributes->>'storage' AS storage
FROM products
WHERE attributes @> '{"5g": true}'::jsonb
ORDER BY price DESC;

-- 3. All unique brands
SELECT DISTINCT attributes->>'brand' AS brand
FROM products
WHERE attributes IS NOT NULL
  AND attributes->>'brand' IS NOT NULL
ORDER BY brand;

-- 4. Products with warranty > 12 months
SELECT
    name,
    attributes->>'brand' AS brand,
    (attributes->>'warranty_months')::INTEGER AS warranty_months,
    price
FROM products
WHERE attributes ? 'warranty_months'
  AND (attributes->>'warranty_months')::INTEGER > 12
ORDER BY warranty_months DESC;</code></pre>
                    </div>
                </div>

                <div class="challenge-box">
                    <h4>Challenge 3: Combined Analytics Report</h4>
                    <p>Create comprehensive analytics reports combining aggregation with JSON operations:</p>
                    <ol>
                        <li><strong>Brand analytics:</strong> Show each brand with product count, average price, min price, and max price.</li>
                        <li><strong>Channel analytics:</strong> Show each order source with order count, total revenue, and average order value.</li>
                        <li><strong>Summary JSON:</strong> Create a single JSON object containing key business metrics (total products, 5G product count, list of brands, total orders, total revenue, list of sources).</li>
                    </ol>

                    <button class="toggle-btn" onclick="toggleSolution('challenge3')">Show Solution</button>
                    <div id="challenge3" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL
-- 1. Brand analytics
SELECT
    attributes->>'brand' AS brand,
    COUNT(*) AS product_count,
    ROUND(AVG(price), 2) AS avg_price,
    MIN(price) AS min_price,
    MAX(price) AS max_price
FROM products
WHERE attributes IS NOT NULL
  AND attributes->>'brand' IS NOT NULL
GROUP BY attributes->>'brand'
ORDER BY product_count DESC;

-- 2. Order source analytics
SELECT
    metadata->>'source' AS source,
    COUNT(*) AS order_count,
    SUM(total_amount) AS total_revenue,
    ROUND(AVG(total_amount), 2) AS avg_order_value
FROM orders
WHERE metadata IS NOT NULL
GROUP BY metadata->>'source'
ORDER BY total_revenue DESC;

-- 3. Summary JSON object
SELECT jsonb_build_object(
    'product_stats', (
        SELECT jsonb_build_object(
            'total_products', COUNT(*),
            'products_with_5g', SUM(CASE WHEN attributes @> '{"5g": true}'::jsonb THEN 1 ELSE 0 END),
            'brands', (SELECT jsonb_agg(DISTINCT attributes->>'brand')
                      FROM products WHERE attributes->>'brand' IS NOT NULL)
        )
        FROM products
        WHERE attributes IS NOT NULL
    ),
    'order_stats', (
        SELECT jsonb_build_object(
            'total_orders', COUNT(*),
            'total_revenue', SUM(total_amount),
            'sources', (SELECT jsonb_agg(DISTINCT metadata->>'source')
                       FROM orders WHERE metadata IS NOT NULL)
        )
        FROM orders
    )
) AS analytics_summary;</code></pre>
                    </div>
                </div>

                <div class="challenge-box">
                    <h4>Challenge 4: Create Indexing Strategy</h4>
                    <p>Design indexes to optimize JSON queries. Choose between expression indexes (B-tree on extracted values) and GIN indexes (full JSON indexing):</p>
                    <ol>
                        <li><strong>Brand queries:</strong> Create an index to speed up queries filtering by brand (e.g., WHERE attributes->>'brand' = 'TechPro').</li>
                        <li><strong>5G containment:</strong> Create a GIN index to support containment queries (e.g., WHERE attributes @> '{"5g": true}').</li>
                        <li><strong>Order source:</strong> Create an index to optimize filtering orders by source channel.</li>
                    </ol>

                    <div class="hint-box">
                        Expression indexes work well for specific paths with B-tree operations (=, <, >). GIN indexes support containment (@>), existence (?), and are flexible but larger.
                    </div>

                    <button class="toggle-btn" onclick="toggleSolution('challenge4')">Show Solution</button>
                    <div id="challenge4" class="solution-box">
                        <pre><code class="language-sql">-- PostgreSQL

-- 1. Index for brand queries (B-tree on extracted value)
CREATE INDEX idx_products_brand ON products ((attributes->>'brand'));

-- 2. GIN index for 5G containment queries
CREATE INDEX idx_products_5g ON products USING GIN (attributes);
-- This supports queries like: WHERE attributes @> '{"5g": true}'

-- Alternative: expression index for specific boolean check
CREATE INDEX idx_products_5g_true ON products ((attributes->>'5g'))
WHERE attributes->>'5g' = 'true';

-- 3. Index for order source
CREATE INDEX idx_orders_source ON orders ((metadata->>'source'));

-- Full JSONB GIN index for flexible querying on products
CREATE INDEX idx_products_attrs_gin ON products USING GIN (attributes);
-- This supports ?, ?|, ?&, @>, <@ operators

-- Full JSONB GIN index for orders metadata
CREATE INDEX idx_orders_meta_gin ON orders USING GIN (metadata);

-- GIN with jsonb_path_ops for containment-only queries (smaller index)
CREATE INDEX idx_products_attrs_path ON products USING GIN (attributes jsonb_path_ops);

-- MySQL

-- 1. Generated column with index for brand
ALTER TABLE products
ADD COLUMN brand_idx VARCHAR(100)
GENERATED ALWAYS AS (attributes->>'$.brand') STORED;
CREATE INDEX idx_products_brand ON products(brand_idx);

-- 2. Generated column for 5g flag
ALTER TABLE products
ADD COLUMN has_5g_idx BOOLEAN
GENERATED ALWAYS AS (CAST(attributes->>'$.5g' AS UNSIGNED) = 1) STORED;
CREATE INDEX idx_products_5g ON products(has_5g_idx);

-- 3. Generated column for source
ALTER TABLE orders
ADD COLUMN source_idx VARCHAR(50)
GENERATED ALWAYS AS (metadata->>'$.source') STORED;
CREATE INDEX idx_orders_source ON orders(source_idx);

-- SQL Server

-- 1. Computed column with index for brand
ALTER TABLE products
ADD brand_computed AS JSON_VALUE(attributes, '$.brand');
CREATE INDEX idx_products_brand ON products(brand_computed);

-- 3. Computed column for source
ALTER TABLE orders
ADD source_computed AS JSON_VALUE(metadata, '$.source');
CREATE INDEX idx_orders_source ON orders(source_computed);</code></pre>
                    </div>
                </div>
            </section>

            <!-- Key Takeaways -->
            <section>
                <h2 id="key-takeaways">Key Takeaways</h2>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Best Practice</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>JSON Type Selection</td>
                            <td>Use <code>JSONB</code> (PostgreSQL) or native <code>JSON</code> (MySQL) for better performance and indexing</td>
                        </tr>
                        <tr>
                            <td>Extracting Values</td>
                            <td>Use <code>->></code> for text output when comparing or displaying, <code>-></code> for nested navigation</td>
                        </tr>
                        <tr>
                            <td>Type Casting</td>
                            <td>Always cast extracted values to appropriate types for comparisons: <code>(data->>'age')::INTEGER</code></td>
                        </tr>
                        <tr>
                            <td>Containment Queries</td>
                            <td>Use <code>@></code> for efficient containment checks, especially with GIN indexes</td>
                        </tr>
                        <tr>
                            <td>Array Expansion</td>
                            <td>Use <code>jsonb_array_elements</code>, <code>JSON_TABLE</code>, or <code>OPENJSON</code> to convert arrays to rows</td>
                        </tr>
                        <tr>
                            <td>Indexing Strategy</td>
                            <td>Create expression indexes on frequently queried paths; use GIN indexes for flexible containment queries</td>
                        </tr>
                        <tr>
                            <td>Schema Design</td>
                            <td>Don't overuse JSON; extract frequently queried fields to regular columns when appropriate</td>
                        </tr>
                        <tr>
                            <td>Cross-Database Portability</td>
                            <td>Be aware of syntax differences; prefer standard <code>JSON_VALUE</code>/<code>JSON_QUERY</code> when possible</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Navigation -->
            <section>
                <p><a href="03_working_with_json.html">&larr; Back to Working with JSON Data Lesson</a></p>
            </section>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <script src="../static/script.js"></script>

    <script>
        function toggleSolution(id) {
            var element = document.getElementById(id);
            if (element.classList.contains('show')) {
                element.classList.remove('show');
                event.target.textContent = 'Show Solution';
            } else {
                element.classList.add('show');
                event.target.textContent = 'Hide Solution';
            }
        }
    </script>
</body>

</html>
